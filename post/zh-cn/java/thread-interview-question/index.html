<!DOCTYPE html><html lang="en" class="scroll-smooth" data-astro-cid-37fxchfa> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.ico" type="image/x-icon"><!-- <link rel="icon" type="image/svg+xml" href="/favicon1.svg" /> --><meta name="generator" content="Astro v4.16.2"><!-- Canonical URL --><link rel="canonical" href="https://blog-template-gray.vercel.app/post/zh-cn/java/thread-interview-question/"><!-- Primary Meta Tags --><title>Thread &amp; ThreaPool • 知道的越多,才知知道的越少</title><!-- ViewTransitions  --><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><!-- SEO --><meta name="title" content="Thread &#38; ThreaPool • 知道的越多,才知知道的越少"><meta name="description" content="线程 &#38; 线程池相关介绍"><meta name="author" content="chou403"><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://blog-template-gray.vercel.app/post/zh-cn/java/thread-interview-question/"><meta property="og:title" content="Thread &#38; ThreaPool"><meta property="og:description" content="线程 &#38; 线程池相关介绍"><meta property="og:image" content="https://blog-template-gray.vercel.app/_astro/dog-1.jpeg"><meta property="article:author" content="chou403"><meta property="article:published_time" content="2024-08-09T14:46:20.000Z"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://blog-template-gray.vercel.app/post/zh-cn/java/thread-interview-question/"><meta property="twitter:title" content="Thread &#38; ThreaPool"><meta property="twitter:description" content="线程 &#38; 线程池相关介绍"><meta property="twitter:image" content="https://blog-template-gray.vercel.app/_astro/dog-1.jpeg"><!-- RSS auto-discovery --><link rel="alternate" type="application/rss+xml" title="知道的越多,才知知道的越少" href="/rss.xml"><link as="font" crossorigin rel="preload" href="/fonts/Manrope-Bold.woff2" type="font/woff2"><style>@font-face {font-weight: 200;font-style: normal;font-family: Manrope;font-display: swap;src: url(/fonts/Manrope-ExtraLight.woff2)} @font-face {font-weight: 300;font-style: normal;font-family: Manrope;font-display: swap;src: url(/fonts/Manrope-Light.woff2)} @font-face {font-weight: 400;font-style: normal;font-family: Manrope;font-display: swap;src: url(/fonts/Manrope-Regular.woff2)} @font-face {font-weight: 500;font-style: normal;font-family: Manrope;font-display: swap;src: url(/fonts/Manrope-Medium.woff2)} @font-face {font-weight: 600;font-style: normal;font-family: Manrope;font-display: swap;src: url(/fonts/Manrope-SemiBold.woff2)} @font-face {font-weight: 700;font-style: normal;font-family: Manrope;font-display: swap;src: url(/fonts/Manrope-Bold.woff2)} @font-face {font-weight: 800;font-style: normal;font-family: Manrope;font-display: swap;src: url(/fonts/Manrope-ExtraBold.woff2)} @font-face { font-family: '_font_fallback_1005409381688'; size-adjust: 103.76%; src: local('Arial'); ascent-override: 102.74%; descent-override: 28.91%; line-gap-override: 0.00%; }</style><script>
	function getTheme() {
		const storedTheme = typeof localStorage !== 'undefined' && localStorage.getItem('theme')

		return (
			storedTheme || (window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark')
		)
	}

	function setTheme(newTheme) {
		const html = document.documentElement
		const isDark = newTheme === 'dark'

		html.classList.toggle('dark', isDark)
		html.classList.toggle('light', !isDark)

		localStorage.setItem('theme', newTheme)
	}

	// set initial theme
	setTheme(getTheme())
	document.addEventListener('astro:after-swap', () => setTheme(getTheme()))

	document.addEventListener('theme-change', (e) => {
		setTheme(e.detail.theme)
	})
</script><script>
	if (!('animations' in localStorage)) {
		localStorage.setItem('animations', 'true')
	} else {
		localStorage.setItem('animations', 'false')
	}
</script><link rel="stylesheet" href="/_astro/_page_.CCiJ3j76.css">
<link rel="stylesheet" href="/_astro/_slug_.Ba2ksmBT.css"><script type="module" src="/_astro/hoisted.D9DAUC0s.js"></script></head> <body class="mx-auto bg-white dark:bg-slate-900 dark:text-slate-400 dark:text-white" data-astro-cid-37fxchfa> <main class="mt-4 grid gap-12 overflow-hidden px-5 antialiased sm:mx-auto sm:max-w-2xl sm:px-8 md:max-w-6xl md:overflow-visible lg:px-0" data-astro-cid-37fxchfa> <header class="fixed left-0 top-0 z-50 flex h-12 w-full items-center bg-[#f8f9fa99] px-5 py-2.5 font-semibold dark:border-slate-50/[0.06] dark:bg-slate-900/60"> <a class="mr-auto text-lg" href="/">Home</a> <div id="astro-header-drawer" class="absolute right-1 top-12 z-50 translate-x-96 rounded-l-lg bg-white p-4 text-slate-500 shadow transition-transform duration-300 ease-in dark:bg-[#0a0910] md:static md:h-auto md:translate-x-0 md:rounded-none md:border-none md:bg-transparent md:p-0 md:shadow-none dark:md:bg-transparent"> <nav class="flex h-full justify-between gap-2 text-left md:w-full md:flex-row md:gap-5"> <div class="flex flex-col gap-4 border-black pr-4 dark:border-white md:flex-row md:border-r-2"> <a href="/tags" class="text-opacity-60 flex items-center gap-1 text-2xl md:text-base" rel="noopener noreferrer ">  <svg xmlns="http://www.w3.org/2000/svg" class="w-8 md:w-6" viewBox="0 0 24 24" stroke-width="1.25" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M7.859 6h-2.834a2.025 2.025 0 0 0 -2.025 2.025v2.834c0 .537 .213 1.052 .593 1.432l6.116 6.116a2.025 2.025 0 0 0 2.864 0l2.834 -2.834a2.025 2.025 0 0 0 0 -2.864l-6.117 -6.116a2.025 2.025 0 0 0 -1.431 -.593z"></path> <path d="M17.573 18.407l2.834 -2.834a2.025 2.025 0 0 0 0 -2.864l-7.117 -7.116"></path> <path d="M6 9h-.01"></path> </svg> Tags
 </a> </div> <div class="flex items-center justify-center gap-3 md:justify-end md:p-0"> <a href="https://github.com/chou403/chou403.github.io" class="text-opacity-60" rel="noopener noreferrer " target="_blank" aria-label="Github">  <span><svg viewBox="0 0 16 16" class="h-5 w-5" fill="currentColor" aria-hidden="true"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg> </span>  </a> </div> <!-- <LanguageSwitcher client:load /> --> </nav> </div> <div class="flex items-center gap-3 text-slate-500 md:pl-3" data-astro-transition-persist="navbar"> <div> <site-search id="search" class="ms-auto"> <button data-open-modal disabled class="flex items-center justify-center rounded-md gap-1"> <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="m19 19-3.5-3.5"></path><circle cx="11" cy="11" r="6"></circle></svg> <!-- <span class='md:hidden text-2xl'> Search</span> --> </button> <dialog aria-label="search" class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-white dark:bg-[#0a0910ec] shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md opacity-0"> <div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6"> <button data-close-modal class="ms-auto cursor-pointer rounded-full bg-black text-white px-4 py-2 dark:bg-white dark:text-black">Close</button> <div class="search-container dark:text-white"> <div id="pagefind__search"></div> </div> </div> </dialog> </site-search>   </div>  <theme-toggle class="relative h-6 w-6"> <button id="toggle-theme" class="group" aria-label="Toggle Theme"> <span class="absolute left-0 right-0 top-0 opacity-0 group-aria-pressed:opacity-100"> <svg viewBox="0 0 24 24" fill="none" class="h-6 w-6"><path fill-rule="evenodd" clip-rule="evenodd" d="M17.715 15.15A6.5 6.5 0 0 1 9 6.035C6.106 6.922 4 9.645 4 12.867c0 3.94 3.153 7.136 7.042 7.136 3.101 0 5.734-2.032 6.673-4.853Z" class="fill-sky-400/20"></path><path d="m17.715 15.15.95.316a1 1 0 0 0-1.445-1.185l.495.869ZM9 6.035l.846.534a1 1 0 0 0-1.14-1.49L9 6.035Zm8.221 8.246a5.47 5.47 0 0 1-2.72.718v2a7.47 7.47 0 0 0 3.71-.98l-.99-1.738Zm-2.72.718A5.5 5.5 0 0 1 9 9.5H7a7.5 7.5 0 0 0 7.5 7.5v-2ZM9 9.5c0-1.079.31-2.082.845-2.93L8.153 5.5A7.47 7.47 0 0 0 7 9.5h2Zm-4 3.368C5 10.089 6.815 7.75 9.292 6.99L8.706 5.08C5.397 6.094 3 9.201 3 12.867h2Zm6.042 6.136C7.718 19.003 5 16.268 5 12.867H3c0 4.48 3.588 8.136 8.042 8.136v-2Zm5.725-4.17c-.81 2.433-3.074 4.17-5.725 4.17v2c3.552 0 6.553-2.327 7.622-5.537l-1.897-.632Z" class="fill-sky-500"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M17 3a1 1 0 0 1 1 1 2 2 0 0 0 2 2 1 1 0 1 1 0 2 2 2 0 0 0-2 2 1 1 0 1 1-2 0 2 2 0 0 0-2-2 1 1 0 1 1 0-2 2 2 0 0 0 2-2 1 1 0 0 1 1-1Z" class="fill-sky-500"></path></svg> </span> <span class="absolute left-0 right-0 top-0 opacity-0 group-aria-[pressed=false]:opacity-100"> <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-6 w-6"><path d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" class="fill-sky-400/20 stroke-sky-500"></path><path d="M12 4v1M17.66 6.344l-.828.828M20.005 12.004h-1M17.66 17.664l-.828-.828M12 20.01V19M6.34 17.664l.835-.836M3.995 12.004h1.01M6 6l.835.836" class="stroke-sky-500"></path></svg> </span> </button> </theme-toggle> <script>
	const button = document.getElementById('toggle-theme')

	function setButtonPresssed() {
		const bodyThemeIsDark = document.documentElement.classList.contains('dark')
		button.setAttribute('aria-pressed', String(bodyThemeIsDark))
	}
	setButtonPresssed()
</script> <button id="toggleMenu" class="md:ml-6 md:hidden"> <svg width="24" height="24"><path d="M5 6h14M5 12h14M5 18h14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg> </button> <button id="astro-header-drawer-button" type="button" class="md:ml-6 md:hidden"> <svg width="24" height="24" fill="none" aria-hidden="true"><path d="M12 6v.01M12 12v.01M12 18v.01M12 7a1 1 0 1 1 0-2 1 1 0 0 1 0 2Zm0 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Zm0 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg> <span class="sr-only">Show Menu</span> </button> </div> </header>  <div class="pointer-events-none absolute inset-x-0 top-0 z-[60] flex justify-center overflow-hidden"> <div class="flex w-[108rem] flex-none justify-end"> <picture> <source srcset="/_astro/docs.BiePeNN8.avif" type="image/avif"> <img src="/_astro/docs.BeNwu2rW_1CTG48.webp" class="w-[71.75rem] max-w-none flex-none dark:hidden" alt="img of docs" width="200" height="200" loading="lazy" decoding="async"> </picture> <picture> <source srcset="/_astro/docs-dark.C7CksN2y.avif" type="image/avif"> <img src="/_astro/docs-dark.Bsq-hjJH_17S3ea.webp" class="hidden w-[90rem] max-w-none flex-none dark:block" alt="img of docs-dark" width="200" height="200" loading="lazy" decoding="async"> </picture> </div> </div>  <article class="mt-12 min-w-full sm:max-w-none md:max-w-none md:py-4"> <header class="mb-3 flex flex-col gap-6"> <div class="flex flex-wrap gap-2"> <div class="flex items-center justify-center"> <h1 class="text-4xl font-semibold md:pb-2.5 md:text-4xl"> 线程 &amp; 线程池相关介绍 </h1> </div> </div> <div class="flex gap-x-1"> <p class="text-center text-sm font-bold text-opacity-50"> chou403 </p> <p class="text-center text-sm font-bold text-opacity-50">
/ Java </p> <p class="text-center text-sm text-opacity-50">
/ <time class="text-sm font-bold text-opacity-60" datetime="2022-09-25T15:20:35.000Z"> Sep 25, 2022 </time> </p> <p class="text-center text-sm font-bold text-opacity-50">
/ 94 min read </p> <!-- {
					data.updatedDate && (
						<span class="text-quote rounded-lg p-1">
							Last Updated:
							<FormattedDate date={data.updatedDate} />
						</span>
					)
				} --> </div> </header> <!-- annotate blog post image --> <!-- <>
			{
				heroImage && (
					<Image
						src={heroImage}
						width={1000}
						height={500}
						quality={100}
						format="jpg"
						loading="eager"
						class="my-8 max-h-[300px] w-full rounded-md object-cover md:max-h-[500px]"
						alt={`img of ${title}`}
					/>
				)
			}
		</> --> <hr> <div>   <div class="mt-8 grid grid-cols-1 gap-10"> <!-- aside  --> <!-- Left menu bar comments --> <!-- <aside class="hidden flex-col gap-8 md:flex">
			<div class="sticky top-12 z-10 hidden self-start transition-all duration-200 md:block">
				{headings && headings.length > 0 && <TableOfContents {headings} />}
			</div>
		</aside> --> <!-- post --> <article class="grid w-full max-w-full"> <div class="prose prose-lg mb-12 min-w-full dark:prose-invert md:prose-xl"> <h2 id="java-中线程的状态">Java 中线程的状态</h2>
<p>5 种状态一般是针对传统的线程状态来说(操作系统层面)</p>
<p><img src="https://cdn.jsdelivr.net/gh/chou403/pic-md@main//img/202402281137874.png" alt="image-20230823173134948"/></p>
<p>Java 中给线程准备了 6 种状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/chou403/pic-md@main//img/202402281130076.png" alt="image-20230823173427644"/></p>
<p><img src="https://cdn.jsdelivr.net/gh/chou403/pic-md@main//img/202402281130198.png" alt="image-20230823173819528"/></p>
<p>NEW: Thread 对象被创建出来,但是还没有执行 start 方法</p>
<p>RUNNABLE: Thread 对象调用了 start 方法,就为 RUNNABLE 状态(CPU 调度/没有调度)</p>
<p>BLOCKED: synchronized 没有拿到同步锁,被阻塞的情况</p>
<p>WAITING: 调用 wait 方法就会处于 WAITING 状态,需要被手动唤醒</p>
<p>TIMED_WAITING: 调用 sleep 方法或者 join 方法,会被自动唤醒,无需手动唤醒</p>
<p>TERMINATED: run 方法执行完毕,线程生命周期到头了</p>
<blockquote>
<p><strong>1)新建状态(NEW)</strong>: 当我们创建一个新的Thread对象时,该线程就处于新建状态,例如: Thread t = new Thread();</p>
<p><strong>2)可运行状态(RUNNABLE)</strong>: 当线程对象调用start()方法后,线程进入可运行状态。在这个状态下,线程已经做好了准备,随时等待CPU调度执行,这个状态包括了”就绪”和”运行”状态。</p>
<p><strong>3)阻塞状态(BLOCKED)</strong>: 线程在等待获取一个锁以进入或重新进入同步代码块时,它会进入阻塞状态。只有当该锁被释放并且线程被调度去获取这个锁,线程才能转换到RUNNABLE状态。</p>
<p><strong>4)等待状态(WAITING)</strong>: 线程进入等待状态,是因为它调用了其它线程的join方法,或者调用了无参数的wait方法。在这种情况下,线程会等待另一个线程的操作完成或者等待notify/notifyAll消息。</p>
<p><strong>5)定时等待状态(TIMED_WAITING</strong>): 线程进入定时等待状态,是因为它调用了sleep或者带有指定时间的wait或join方法。在指定的时间过去之后,线程会自动返回RUNNABLE状态。如果它是由于调用wait或join方法进入的定时等待状态,还需要等待notify/notifyAll消息或者等待join的线程终止。</p>
<p><strong>6)终止状态(TERMINATED)</strong>: 线程任务执行完毕或者由于异常而结束,线程就会进入终止状态。在这个状态下,线程的生命周期实际上已经结束了,它不能再转换到其他任何状态。</p>
</blockquote>
<p>BLOCKED,WAITING,TIMED_WAITING: 都可以理解为阻塞,等待状态,因为处在这三种状态下,CPU 不会调度当前线程</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#E1E4E8">NEW</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#E1E4E8">Thread thread </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8">(()</span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"><span style="color:#E1E4E8">System.out.</span><span style="color:#B392F0">println</span><span style="color:#E1E4E8">(thread.</span><span style="color:#B392F0">getState</span><span style="color:#E1E4E8">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">RUNNABLE</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#E1E4E8">Thread thread </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8">(()</span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"><span style="color:#E1E4E8">thread.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">System.out.</span><span style="color:#B392F0">println</span><span style="color:#E1E4E8">(thread.</span><span style="color:#B392F0">getState</span><span style="color:#E1E4E8">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">BLOCKED</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#E1E4E8">Object object </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Object</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">Thread thread </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8">(()</span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">    synchronized</span><span style="color:#E1E4E8"> (object) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"><span style="color:#F97583">synchronized</span><span style="color:#E1E4E8"> (object) {</span></span>
<span class="line"><span style="color:#E1E4E8">    thread.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    Thread.</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">500</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    System.out.</span><span style="color:#B392F0">println</span><span style="color:#E1E4E8">(thread.</span><span style="color:#B392F0">getState</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">WAITING</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#E1E4E8">Object object </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Object</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">Thread thread </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    synchronized</span><span style="color:#E1E4E8"> (object) {</span></span>
<span class="line"><span style="color:#F97583">        try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">            object.</span><span style="color:#B392F0">wait</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (InterruptedException </span><span style="color:#FFAB70">e</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">            e.</span><span style="color:#B392F0">printStackTrace</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"><span style="color:#E1E4E8">thread.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">Thread.</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">500</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">System.out.</span><span style="color:#B392F0">println</span><span style="color:#E1E4E8">(thread.</span><span style="color:#B392F0">getState</span><span style="color:#E1E4E8">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">TIMED_WAITING</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#E1E4E8">Thread thread </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        Thread.</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1000</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (InterruptedException </span><span style="color:#FFAB70">e</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">        e.</span><span style="color:#B392F0">printStackTrace</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"><span style="color:#E1E4E8">thread.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">Thread.</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">500</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">System.out.</span><span style="color:#B392F0">println</span><span style="color:#E1E4E8">(thread.</span><span style="color:#B392F0">getState</span><span style="color:#E1E4E8">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">TERMINATED</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#E1E4E8">Thread thread </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        Thread.</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">500</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (InterruptedException </span><span style="color:#FFAB70">e</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">        e.</span><span style="color:#B392F0">printStackTrace</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"><span style="color:#E1E4E8">thread.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">Thread.</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1000</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">System.out.</span><span style="color:#B392F0">println</span><span style="color:#E1E4E8">(thread.</span><span style="color:#B392F0">getState</span><span style="color:#E1E4E8">());</span></span>
<span class="line"></span></code></pre> </div> 
<h2 id="threadpool">ThreadPool</h2>
<p><img src="https://cdn.jsdelivr.net/gh/chou403/pic-md@main/img/image-20230411174505779.png" alt="image-20230411174505779"/></p>
<h3 id="jdk-提供的线程池">JDK 提供的线程池</h3>
<h4 id="newfixedthreadpool">newFixedThreadPool</h4>
<p>这个线程的特点是线程数是固定的。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> static</span><span style="color:#E1E4E8"> ExecutorService </span><span style="color:#B392F0">newFixedThreadPool</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> nThreads) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> ThreadPoolExecutor</span><span style="color:#E1E4E8">(nThreads, nThreads,</span></span>
<span class="line"><span style="color:#79B8FF">                                  0L</span><span style="color:#E1E4E8">, TimeUnit.MILLISECONDS,</span></span>
<span class="line"><span style="color:#F97583">                                  new</span><span style="color:#E1E4E8"> LinkedBlockingQueue&lt;</span><span style="color:#F97583">Runnable</span><span style="color:#E1E4E8">&gt;());</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>构建时,需要给 newFixedThreadPool 方法提供一个 nThreads 的属性,而这个属性就是当前线程池线程的个数,当前线程池的本质其实就是使用 ThreadPoolExecutor。</p>
<p>构建好当前线程池后,线程个数已经固定好(线程是懒加载,在构建之初,线程并没有构建出来,而是随着任务的提交才会将线程在线程池中构建出来)。如果线程没有构建,线程会待着任务执行被创建和执行。如果线程都已经构建好了,此时任务会被放到 LinkedBlockingQueue 无界队列中存放,等待线程从 LinkedBlockingQueue 中去 take 出去,然后执行。</p>
<h4 id="newsinglethreadexecutor">newSingleThreadExecutor</h4>
<p>单例线程池,该线程池只有一个工作线程在处理任务,如果业务是顺序消费们可以采用该线程池。</p>
<p>这种线程池比较简单,它内部只有一个线程,会用唯一的工作线程来执行任务。它的原理和固定线程数量的线程池的原理是一样的,只不过这个时候它的线程数量就直接被设置为 1,也就是只有一个线程。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> static</span><span style="color:#E1E4E8"> ExecutorService </span><span style="color:#B392F0">newSingleThreadExecutor</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> new</span><span style="color:#E1E4E8"> FinalizableDelegatedExecutorService</span></span>
<span class="line"><span style="color:#E1E4E8">        (</span><span style="color:#F97583">new</span><span style="color:#B392F0"> ThreadPoolExecutor</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">                                0L</span><span style="color:#E1E4E8">, TimeUnit.MILLISECONDS,</span></span>
<span class="line"><span style="color:#F97583">                                new</span><span style="color:#E1E4E8"> LinkedBlockingQueue&lt;</span><span style="color:#F97583">Runnable</span><span style="color:#E1E4E8">&gt;()));</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> FinalizableDelegatedExecutorService</span></span>
<span class="line"><span style="color:#F97583">            extends</span><span style="color:#B392F0"> DelegatedExecutorService</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    FinalizableDelegatedExecutorService</span><span style="color:#E1E4E8">(ExecutorService </span><span style="color:#FFAB70">executor</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">        super</span><span style="color:#E1E4E8">(executor);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    @</span><span style="color:#F97583">SuppressWarnings</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;deprecation&quot;</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">    protected</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> finalize</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#79B8FF">        super</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">shutdown</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>单例线程池,线程池中只有一个工作线程在处理任务。</p>
<p>如果业务中涉及了顺序消费,可以采用 newSingleThreadExecutor。</p>
<h4 id="newcachedthreadpool">newCachedThreadPool</h4>
<p>缓存线程池,corePoolSize为0,当第一次提交任务到线程池时,会直接构建一个工作线程,Integer.MAX_VALUE: 意味着线程数量可以无限大,keepAliveTime为60S,60秒内没有任务进来,意味着线程空闲时间超过60S就会被杀死;如果在等待60秒期间有任务进来,他会再次拿到这个任务去执行,特点是: 任务只要提交到该线程池就必然有工作线程处理。</p>
<p>它是可缓存的线程池,并且还会回收。它会把任务交给我们的线程,而且线程不够用的话,就会创建线程。如果线程过多,就会把这些线程给回收回来。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> static</span><span style="color:#E1E4E8"> ExecutorService </span><span style="color:#B392F0">newCachedThreadPool</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> ThreadPoolExecutor</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, Integer.MAX_VALUE,</span></span>
<span class="line"><span style="color:#79B8FF">                                  60L</span><span style="color:#E1E4E8">, TimeUnit.SECONDS,</span></span>
<span class="line"><span style="color:#F97583">                                  new</span><span style="color:#E1E4E8"> SynchronousQueue&lt;</span><span style="color:#F97583">Runnable</span><span style="color:#E1E4E8">&gt;());</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<h4 id="newscheduledthreadpool">newScheduledThreadPool</h4>
<p>定时线程池,创建一个定时线程池,即按一定的周期执行任务,即定时任务,或者设置定时时间,延迟执行任务,由于该线程池是继承ThreadPoolExecutor,所以本质上还是ThreadPoolExecutor线程池,只不过是在原来的基础上添加了定时功能,其原理是基于DelayQueue实现延迟执行,周期性执行,任务执行完毕,再次扔会到阻塞队列。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> static</span><span style="color:#E1E4E8"> ScheduledExecutorService </span><span style="color:#B392F0">newScheduledThreadPool</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#F97583">            int</span><span style="color:#E1E4E8"> corePoolSize, ThreadFactory threadFactory) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> ScheduledThreadPoolExecutor</span><span style="color:#E1E4E8">(corePoolSize, threadFactory);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">public</span><span style="color:#B392F0"> ScheduledThreadPoolExecutor</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> corePoolSize,</span></span>
<span class="line"><span style="color:#E1E4E8">                                       ThreadFactory threadFactory) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(corePoolSize, Integer.MAX_VALUE,</span></span>
<span class="line"><span style="color:#E1E4E8">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span></span>
<span class="line"><span style="color:#F97583">          new</span><span style="color:#B392F0"> DelayedWorkQueue</span><span style="color:#E1E4E8">(), threadFactory);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<h4 id="newworkstealingpool">newWorkStealingPool</h4>
<p>newWorkStealingPool简单翻译是<strong>任务窃取</strong>线程池。和别的4种不同,它用的是ForkJoinPool。使用ForkJoinPool的好处是,把1个任务拆分成多个”<strong>小任务</strong>”,把这些”<strong>小任务</strong>”分发到多个线程上执行。这些”<strong>小任务</strong>”都执行完成后,再将结果<strong>合并</strong>。之前的线程池中,多个线程共有一个阻塞队列,而newWorkStealingPool 中每一个线程都有一个自己的队列。当线程发现自己的队列没有任务了,就会到别的线程的队列里获取任务执行。可以简单理解为”<strong>窃取</strong>”。一般是自己的本地队列采取LIFO(后进先出),窃取时采用FIFO(先进先出),一个从头开始执行,一个从尾部开始执行,由于偷取的动作十分快速,会大量降低这种冲突,也是一种优化方式。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> static</span><span style="color:#E1E4E8"> ExecutorService </span><span style="color:#B392F0">newWorkStealingPool</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> new</span><span style="color:#E1E4E8"> ForkJoinPool</span></span>
<span class="line"><span style="color:#E1E4E8">        (Runtime.</span><span style="color:#B392F0">getRuntime</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">availableProcessors</span><span style="color:#E1E4E8">(),</span></span>
<span class="line"><span style="color:#E1E4E8">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span></span>
<span class="line"><span style="color:#79B8FF">         null</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<h3 id="核心参数">核心参数</h3>
<p>为什么要自定义线程池, 首先 ThreadPoolExecutor 中,一种提供了 7 个参数,每个参数都是非常核心的属性,在线程池去执行任务时,每个参数都有决定性的作用。</p>
<p>但是如果直接采用 JDK 提供的方式去构建,可以设置的参数最多两个,这样就会导致对线程池的控制粒度很粗。所以在阿里规范中也推荐去自定义线程池。手动的去 new ThreadPoolExecutor 设置它的一些核心属性。</p>
<p>自定义构建线程池,可以细粒度的控制线程池,去管理内存的属性,并且针对一些参数的设置可能更好的在后期排查问题。</p>
<h4 id="自定义线程池七大参数">自定义线程池七大参数</h4>
<ul>
<li>
<p><strong>int corePoolSize</strong></p>
<p>核心线程数,创建线程池后不会立即创建核心线程,当有任务到达时才触发核心线程的创建,当线程池中的线程数目达到corePoolSize后,就会把到达的任务放到缓存队列当中。核心线程在allowCoreThreadTimeout被设置为true时会超时并被回收,默认情况下不会被回收。</p>
</li>
<li>
<p><strong>int maximumPoolSize</strong></p>
<p>最大线程数,代表当前线程池中,一共可以有多少个工作线程。当线程数大于或等于corePoolSize,且任务队列已满时,线程池会创建新的线程,直到线程数量达到maxPoolSize。如果线程数已等于maxPoolSize,且任务队列已满,则已超出线程池的处理能力,线程池会按照rejectedExecutionHandler配置的处理策略进行处理线程。</p>
</li>
<li>
<p><strong>long keepAliveTime</strong></p>
<p>非核心工作线程在阻塞队列位置等待的时间,当线程空闲时间达到keepAliveTime,该线程会退出,直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为true,则所有线程均会退出直到线程数量为0。</p>
</li>
<li>
<p><strong>TimeUnit unit</strong></p>
<p>非核心工作线程在阻塞队列位置等待时间的单位。</p>
</li>
<li>
<p><strong>BlockingQueue&lt;Runnable&gt; workQueue</strong></p>
<p>任务没有在核心工作线程处理时,任务先扔到阻塞队列中。阻塞队列,用来存储等待执行的任务,新任务被提交后,会先进入到此工作队列中,任务调度时再从队列中取出任务。这里的阻塞队列有以下几种选择:</p>
<ul>
<li>ArrayBlockingQueue: 基于数组的有界阻塞队列,按FIFO排序</li>
<li>LinkedBlockingQueue: 基于链表的无界阻塞队列(其实最大容量为Interger.MAX),按照FIFO排序</li>
<li>PriorityBlockingQueue: 具有优先级的无界阻塞队列,优先级通过参数Comparator实现</li>
<li>SynchronousQueue: 一个不缓存任务的阻塞队列,也就是说新任务进来时,不会缓存,而是直接被调度执行该任务</li>
</ul>
</li>
<li>
<p><strong>ThreadFactory threadFactory</strong></p>
<p>线程工厂,创建一个新线程时使用的工厂,可以用来设定线程名,是否为daemon线程等等。在构建线程的线程工作,可以设置thread 的一些信息。</p>
</li>
<li>
<p><strong>RejectedExecutionHandler handler</strong></p>
<p>当前线程池无法处理投递过来的任务时,执行当前的拒绝策略 。拒绝策略有以下:</p>
<ul>
<li>AbortPolicy: 当前拒绝策略在无法处理任务时,会抛出一个异常</li>
<li>CallerRunPolicy: 当前拒绝策略在线程池无法处理任务时,会将任务交给调用者处理</li>
<li>DiscardPolicy: 当前拒绝策略在无法处理任务时,会直接将任务丢掉</li>
<li>DiscardOldestPolicy: 当前拒绝策略在无法处理任务时,将队列中最早的任务丢掉,将当前<strong>再次尝试</strong>交给线程池处理</li>
<li>自定义Policy: 根据自己的任务,将任务扔到数据库,也可以做其他操作。</li>
</ul>
</li>
</ul>
<h3 id="线程池的状态">线程池的状态</h3>
<p>线程池的5种状态: RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#6A737D">// 是个int类型的数值 表达了两个意思 1: 声明当前线程池的状态 2: 声明线程池中的线程数</span></span>
<span class="line"><span style="color:#6A737D">// 高3位是线程池状态 低29位是线程池中线程个数</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> final</span><span style="color:#E1E4E8"> AtomicInteger ctl </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> AtomicInteger</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">ctlOf</span><span style="color:#E1E4E8">(RUNNING, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#6A737D">// 29 方便后面的位运算</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> COUNT_BITS </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Integer.SIZE </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 3</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">// 通过位运算得出最大容量</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> COUNT_MASK </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &lt;&lt;</span><span style="color:#E1E4E8"> COUNT_BITS) </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// runState is stored in the high-order bits</span></span>
<span class="line"><span style="color:#6A737D">// 线程池状态</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> RUNNING    </span><span style="color:#F97583">=</span><span style="color:#F97583"> -</span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &lt;&lt;</span><span style="color:#E1E4E8"> COUNT_BITS; </span><span style="color:#6A737D">// 111 代表线程池为RUNNING,代表正常接收任务</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> SHUTDOWN   </span><span style="color:#F97583">=</span><span style="color:#79B8FF">  0</span><span style="color:#F97583"> &lt;&lt;</span><span style="color:#E1E4E8"> COUNT_BITS; </span><span style="color:#6A737D">// 000 代表线程池为SHUTDOWN,不接收新任务,但是内部还会处理阻塞队列中的任务,正在进行的任务也会正常处理</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> STOP       </span><span style="color:#F97583">=</span><span style="color:#79B8FF">  1</span><span style="color:#F97583"> &lt;&lt;</span><span style="color:#E1E4E8"> COUNT_BITS; </span><span style="color:#6A737D">// 001 代表线程池为STOP,不接收新任务,也不会处理阻塞队列中的任务,同时会中断正在进行的任务</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> TIDYING    </span><span style="color:#F97583">=</span><span style="color:#79B8FF">  2</span><span style="color:#F97583"> &lt;&lt;</span><span style="color:#E1E4E8"> COUNT_BITS; </span><span style="color:#6A737D">// 010 代表线程池为TIDYING,过渡的状态,代表当前线程池即将 Game Over</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> TERMINATED </span><span style="color:#F97583">=</span><span style="color:#79B8FF">  3</span><span style="color:#F97583"> &lt;&lt;</span><span style="color:#E1E4E8"> COUNT_BITS; </span><span style="color:#6A737D">// 011 代表线程池TERMINATED,代表当前线程池已经 Game Over,要执行terminated()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// Packing and unpacking ctl</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> runStateOf</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> c)     { </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">&amp;</span><span style="color:#F97583"> ~</span><span style="color:#E1E4E8">COUNT_MASK; } </span><span style="color:#6A737D">// 得到线程池的状态</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> workerCountOf</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> c)  { </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8"> COUNT_MASK; } </span><span style="color:#6A737D">// 得到当前线程池的线程数量</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> ctlOf</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> rs, </span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> wc) { </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> rs </span><span style="color:#F97583">|</span><span style="color:#E1E4E8"> wc; } </span><span style="color:#6A737D">// 得到上面提到的 32 位 int类型的数值</span></span>
<span class="line"></span></code></pre> </div> 
<ul>
<li>
<p>RUNNING</p>
<p>线程池一旦被创建,就处于 RUNNING 状态,任务数为 0,能够接收新任务,对已排队的任务进行处理。</p>
</li>
<li>
<p>SHUTDOWN</p>
<p>不接收新任务,但能处理已排队的任务。调用线程池的 shutdown() 方法,线程池由 RUNNING 转变为 SHUTDOWN 状态。</p>
</li>
<li>
<p>STOP</p>
<p>不接收新任务,不处理已排队的任务,并且会中断正在处理的任务。调用线程池的 shutdownNow() 方法,线程池由(RUNNING 或 SHUTDOWN ) 转变为 STOP 状态。</p>
</li>
<li>
<p>TIDYING</p>
<ul>
<li>SHUTDOWN 状态下,任务数为 0, 其他所有任务已终止,线程池会变为 TIDYING 状态,会执行 terminated() 方法。线程池中的 terminated() 方法是空实现,可以重写该方法进行相应的处理。</li>
<li>线程池在 SHUTDOWN 状态,任务队列为空且执行中任务为空,线程池就会由 SHUTDOWN 转变为 TIDYING 状态。</li>
<li>线程池在 STOP 状态,线程池中执行中任务为空时,就会由 STOP 转变为 TIDYING 状态。</li>
</ul>
</li>
<li>
<p>TERMINATED</p>
<p>线程池彻底终止。线程池在 TIDYING 状态执行完 terminated() 方法就会由 TIDYING 转变为 TERMINATED 状态。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/chou403/pic-md@main/img/image-20230411173800910.png" alt="image-20230411173800910"/></p>
<h3 id="线程池执行流程">线程池执行流程</h3>
<p>ThreadPoolExecutor 的 <strong>execute()</strong> 是提任务到线程池的核心方法,很重要。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> execute</span><span style="color:#E1E4E8">(Runnable command) {</span></span>
<span class="line"><span style="color:#6A737D">  // 提交的任务不能为 null</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (command </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">    throw</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> NullPointerException</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">  /*</span></span>
<span class="line"><span style="color:#6A737D">    * Proceed in 3 steps:</span></span>
<span class="line"><span style="color:#6A737D">    *</span></span>
<span class="line"><span style="color:#6A737D">    * 1. If fewer than corePoolSize threads are running, try to</span></span>
<span class="line"><span style="color:#6A737D">    * start a new thread with the given command as its first</span></span>
<span class="line"><span style="color:#6A737D">    * task.  The call to addWorker atomically checks runState and</span></span>
<span class="line"><span style="color:#6A737D">    * workerCount, and so prevents false alarms that would add</span></span>
<span class="line"><span style="color:#6A737D">    * threads when it shouldn&#39;t, by returning false.</span></span>
<span class="line"><span style="color:#6A737D">    *</span></span>
<span class="line"><span style="color:#6A737D">    * 2. If a task can be successfully queued, then we still need</span></span>
<span class="line"><span style="color:#6A737D">    * to double-check whether we should have added a thread</span></span>
<span class="line"><span style="color:#6A737D">    * (because existing ones died since last checking) or that</span></span>
<span class="line"><span style="color:#6A737D">    * the pool shut down since entry into this method. So we</span></span>
<span class="line"><span style="color:#6A737D">    * recheck state and if necessary roll back the enqueuing if</span></span>
<span class="line"><span style="color:#6A737D">    * stopped, or start a new thread if there are none.</span></span>
<span class="line"><span style="color:#6A737D">    *</span></span>
<span class="line"><span style="color:#6A737D">    * 3. If we cannot queue task, then we try to add a new</span></span>
<span class="line"><span style="color:#6A737D">    * thread.  If it fails, we know we are shut down or saturated</span></span>
<span class="line"><span style="color:#6A737D">    * and so reject the task.</span></span>
<span class="line"><span style="color:#6A737D">    */</span></span>
<span class="line"><span style="color:#6A737D">  // 获取核心线程 ctl,用于后面的判断</span></span>
<span class="line"><span style="color:#F97583">  int</span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">  // 如果工作线程个数小于核心线程数</span></span>
<span class="line"><span style="color:#6A737D">  // 满足要求,添加核心工作线程</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">workerCountOf</span><span style="color:#E1E4E8">(c) </span><span style="color:#F97583">&lt;</span><span style="color:#E1E4E8"> corePoolSize) {</span></span>
<span class="line"><span style="color:#6A737D">    // addWorker(任务,是核心线程吗)</span></span>
<span class="line"><span style="color:#6A737D">    // addWorker返回 true,代表添加工作线程成功</span></span>
<span class="line"><span style="color:#6A737D">    // addWorker返回 false,代表添加工作线程失败</span></span>
<span class="line"><span style="color:#6A737D">    // addWorker中会基于线程池状态,以及工作线程个数做判断,查看能否添加工作线程</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">addWorker</span><span style="color:#E1E4E8">(command, </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">))</span></span>
<span class="line"><span style="color:#6A737D">        // 工作线程构建出来了,任务也交给 command 去处理了</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">    // 说明线程池状态或者是工作线程个数发生了变化,导致添加失败,重新获取一次 ctl</span></span>
<span class="line"><span style="color:#E1E4E8">    c </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#6A737D">  // 添加核心工作线程失败,调用一下</span></span>
<span class="line"><span style="color:#6A737D">  // 判断线程池状态是否是 RUNNING,如果是,正常基于阻塞队列的 offer 方法,将任务添加到阻塞队列</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isRunning</span><span style="color:#E1E4E8">(c) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#E1E4E8"> workQueue.</span><span style="color:#B392F0">offer</span><span style="color:#E1E4E8">(command)) {</span></span>
<span class="line"><span style="color:#6A737D">    // 如果任务添加到阻塞队列成功,走 if 内部</span></span>
<span class="line"><span style="color:#6A737D">    // 如果任务在扔到阻塞队列之前,线程池状态突然改变了</span></span>
<span class="line"><span style="color:#6A737D">    // 重新获取 ctl</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> recheck </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">    // 如果线程池的状态不是 RUNNING,将任务从阻塞队列中移除</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#B392F0"> isRunning</span><span style="color:#E1E4E8">(recheck) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> remove</span><span style="color:#E1E4E8">(command))</span></span>
<span class="line"><span style="color:#6A737D">      // 并且直接拒绝策略</span></span>
<span class="line"><span style="color:#B392F0">      reject</span><span style="color:#E1E4E8">(command);</span></span>
<span class="line"><span style="color:#6A737D">    // 在这,说明阻塞队列有我刚刚放进去的任务</span></span>
<span class="line"><span style="color:#6A737D">    // 查看一下工作线程数是不是 0 个</span></span>
<span class="line"><span style="color:#6A737D">    // 如果工作线程为 0 个,需要添加一个非核心工作线程去处理阻塞队列中的任务</span></span>
<span class="line"><span style="color:#6A737D">    // 发生这种情况有两种:</span></span>
<span class="line"><span style="color:#6A737D">    // 1.构建线程池时,核心线程数为 0 个</span></span>
<span class="line"><span style="color:#6A737D">    // 2.即便有核心线程,可以设置核心线程也允许超时,设置 allowCoreThreadTimeOut 为 true,代表核心线程也可以关闭</span></span>
<span class="line"><span style="color:#F97583">    else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">workerCountOf</span><span style="color:#E1E4E8">(recheck) </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#6A737D">      // 为了避免阻塞队列中的任务饥饿,添加一个非核心工作线程去处理</span></span>
<span class="line"><span style="color:#B392F0">      addWorker</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">false</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#6A737D">  // 任务添加到阻塞队列失败</span></span>
<span class="line"><span style="color:#6A737D">  // 构建一个非核心工作线程</span></span>
<span class="line"><span style="color:#6A737D">  // 如果添加非核心工作线程成功,直接完事</span></span>
<span class="line"><span style="color:#F97583">  else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#B392F0">addWorker</span><span style="color:#E1E4E8">(command, </span><span style="color:#79B8FF">false</span><span style="color:#E1E4E8">))</span></span>
<span class="line"><span style="color:#6A737D">    // 添加失败,执行拒绝策略</span></span>
<span class="line"><span style="color:#B392F0">    reject</span><span style="color:#E1E4E8">(command);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p><img src="https://cdn.jsdelivr.net/gh/chou403/pic-md@main//img/202402281131682.png" alt="image-20230828000746127"/></p>
<p><strong>addWorker()</strong> 中主要分成两大部分去看</p>
<ul>
<li>校验线程池的状态以及工作线程个数</li>
<li>添加工作线程并且启动工作线程</li>
</ul>
<p>校验线程池的状态以及工作线程个数</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> boolean</span><span style="color:#B392F0"> addWorker</span><span style="color:#E1E4E8">(Runnable firstTask, </span><span style="color:#F97583">boolean</span><span style="color:#E1E4E8"> core) {</span></span>
<span class="line"><span style="color:#E1E4E8">  retry</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#6A737D">  // 循环检查状态</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();;) {</span></span>
<span class="line"><span style="color:#6A737D">    // Check if queue empty only if necessary.</span></span>
<span class="line"><span style="color:#6A737D">    // 检查线程池的运行状态是否 shutdown,任务队列是否为空等状态是否正常</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">runStateAtLeast</span><span style="color:#E1E4E8">(c, SHUTDOWN)</span></span>
<span class="line"><span style="color:#F97583">      &amp;&amp;</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">runStateAtLeast</span><span style="color:#E1E4E8">(c, STOP)</span></span>
<span class="line"><span style="color:#F97583">        ||</span><span style="color:#E1E4E8"> firstTask </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> null</span></span>
<span class="line"><span style="color:#F97583">        ||</span><span style="color:#E1E4E8"> workQueue.</span><span style="color:#B392F0">isEmpty</span><span style="color:#E1E4E8">()))</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // 循环更新状态,和线程数量的更新,都是使用 CAS 的模式更新</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (;;) {</span></span>
<span class="line"><span style="color:#6A737D">      // 检查运行的线程数是否超标</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">workerCountOf</span><span style="color:#E1E4E8">(c)</span></span>
<span class="line"><span style="color:#F97583">        &gt;=</span><span style="color:#E1E4E8"> ((core </span><span style="color:#F97583">?</span><span style="color:#E1E4E8"> corePoolSize </span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> maximumPoolSize) </span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8"> COUNT_MASK))</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">      // CAS 方式更新线程数量</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">compareAndIncrementWorkerCount</span><span style="color:#E1E4E8">(c))</span></span>
<span class="line"><span style="color:#6A737D">        // 更新成功后直接跳转到方法第一行,并且不在进入这些 for 循环中</span></span>
<span class="line"><span style="color:#6A737D">        // 因为状态啥的已经更新成功了</span></span>
<span class="line"><span style="color:#F97583">        break</span><span style="color:#E1E4E8"> retry;</span></span>
<span class="line"><span style="color:#E1E4E8">      c </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();  </span><span style="color:#6A737D">// Re-read ctl</span></span>
<span class="line"><span style="color:#6A737D">      // 如果 CAS 增加线程数失败,检查下状态是否还是和之前一样</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">runStateAtLeast</span><span style="color:#E1E4E8">(c, SHUTDOWN))</span></span>
<span class="line"><span style="color:#6A737D">        // 不一样了,会跳转到第一行,并会重新进入 for 循环中走一遍流程</span></span>
<span class="line"><span style="color:#F97583">        continue</span><span style="color:#E1E4E8"> retry;</span></span>
<span class="line"><span style="color:#6A737D">      // else CAS failed due to workerCount change; retry inner loop</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  boolean</span><span style="color:#E1E4E8"> workerStarted </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">  boolean</span><span style="color:#E1E4E8"> workerAdded </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  Worker w </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">  try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">    // 新建一个 worker,内部包含线程</span></span>
<span class="line"><span style="color:#E1E4E8">    w </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Worker</span><span style="color:#E1E4E8">(firstTask);</span></span>
<span class="line"><span style="color:#6A737D">    // 获取内部的线程对象</span></span>
<span class="line"><span style="color:#F97583">    final</span><span style="color:#E1E4E8"> Thread t </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> w.thread;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (t </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">      // 加锁,锁定</span></span>
<span class="line"><span style="color:#F97583">      final</span><span style="color:#E1E4E8"> ReentrantLock mainLock </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.mainLock;</span></span>
<span class="line"><span style="color:#E1E4E8">      mainLock.</span><span style="color:#B392F0">lock</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">      try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        // Recheck while holding lock.</span></span>
<span class="line"><span style="color:#6A737D">        // Back out on ThreadFactory failure or if</span></span>
<span class="line"><span style="color:#6A737D">        // shut down before lock acquired.</span></span>
<span class="line"><span style="color:#F97583">        int</span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">        // 二次检查线程池的状态</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isRunning</span><span style="color:#E1E4E8">(c) </span><span style="color:#F97583">||</span></span>
<span class="line"><span style="color:#E1E4E8">          (</span><span style="color:#B392F0">runStateLessThan</span><span style="color:#E1E4E8">(c, STOP) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#E1E4E8"> firstTask </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">)) {</span></span>
<span class="line"><span style="color:#6A737D">          // 池的状态没有问题,检查线程是否存活</span></span>
<span class="line"><span style="color:#F97583">          if</span><span style="color:#E1E4E8"> (t.</span><span style="color:#B392F0">getState</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> Thread.State.NEW)</span></span>
<span class="line"><span style="color:#F97583">            throw</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> IllegalThreadStateException</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">          // worker 放入池的 hashset 中</span></span>
<span class="line"><span style="color:#E1E4E8">          workers.</span><span style="color:#B392F0">add</span><span style="color:#E1E4E8">(w);</span></span>
<span class="line"><span style="color:#E1E4E8">          workerAdded </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">          int</span><span style="color:#E1E4E8"> s </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> workers.</span><span style="color:#B392F0">size</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">          // 并将 worker 的数量赋予池中的 largestPoolSize 成员变量</span></span>
<span class="line"><span style="color:#F97583">          if</span><span style="color:#E1E4E8"> (s </span><span style="color:#F97583">&gt;</span><span style="color:#E1E4E8"> largestPoolSize)</span></span>
<span class="line"><span style="color:#E1E4E8">            largestPoolSize </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> s;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">finally</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        mainLock.</span><span style="color:#B392F0">unlock</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#6A737D">      // worker 创建成功并加入 workers 成功</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (workerAdded) {</span></span>
<span class="line"><span style="color:#6A737D">        // 启动线程</span></span>
<span class="line"><span style="color:#E1E4E8">        t.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">        // 修改状态</span></span>
<span class="line"><span style="color:#E1E4E8">        workerStarted </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">finally</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8"> workerStarted)</span></span>
<span class="line"><span style="color:#6A737D">      // 启动线程失败,进行失败处理</span></span>
<span class="line"><span style="color:#B392F0">      addWorkerFailed</span><span style="color:#E1E4E8">(w);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> workerStarted;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#6A737D">// 如果可以在不超过队列容量的情况下立即插入指定的元素,则在该队列的尾部插入该元素;如果成功,则返回true;如果该队列已满,则返回false</span></span>
<span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> boolean</span><span style="color:#B392F0"> offer</span><span style="color:#E1E4E8">(E e) {</span></span>
<span class="line"><span style="color:#6A737D">    // 不允许元素为空</span></span>
<span class="line"><span style="color:#E1E4E8">    Objects.</span><span style="color:#B392F0">requireNonNull</span><span style="color:#E1E4E8">(e);</span></span>
<span class="line"><span style="color:#F97583">    final</span><span style="color:#E1E4E8"> ReentrantLock lock </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.lock;</span></span>
<span class="line"><span style="color:#E1E4E8">    lock.</span><span style="color:#B392F0">lock</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// 加锁 保证调用 offer 方法的时候只有一个线程</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        // 队列满</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (count </span><span style="color:#F97583">==</span><span style="color:#E1E4E8"> items.length)</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">        else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">            // 队列未满</span></span>
<span class="line"><span style="color:#B392F0">            enqueue</span><span style="color:#E1E4E8">(e);</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">finally</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        // 释放锁 让其他线程可以调用 offer 方法</span></span>
<span class="line"><span style="color:#E1E4E8">        lock.</span><span style="color:#B392F0">unlock</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#6A737D">// 在当前放置位置插入元素,前进和发出信号。只有在锁定的情况下才能呼叫。</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> enqueue</span><span style="color:#E1E4E8">(E e) {</span></span>
<span class="line"><span style="color:#F97583">    final</span><span style="color:#F97583"> Object</span><span style="color:#E1E4E8">[] items </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.items;</span></span>
<span class="line"><span style="color:#6A737D">    // 元素添加到数组中</span></span>
<span class="line"><span style="color:#E1E4E8">    items[putIndex] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> e;</span></span>
<span class="line"><span style="color:#6A737D">    // 当索引满了 修改为0</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">putIndex </span><span style="color:#F97583">==</span><span style="color:#E1E4E8"> items.length) putIndex </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    count</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">    // 使用条件对象 notEmpty 通知 比如使用 take 方法的时候队列中没有数据 被阻塞 这个时候队列中插入了数据 需要调用 signal() 进行通知</span></span>
<span class="line"><span style="color:#E1E4E8">    notEmpty.</span><span style="color:#B392F0">signal</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<h3 id="woker">Woker</h3>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> final</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> Worker</span></span>
<span class="line"><span style="color:#F97583">        extends</span><span style="color:#B392F0"> AbstractQueuedSynchronizer</span></span>
<span class="line"><span style="color:#F97583">        implements</span><span style="color:#B392F0"> Runnable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  /**</span></span>
<span class="line"><span style="color:#6A737D">   * This class will never be serialized, but we provide a</span></span>
<span class="line"><span style="color:#6A737D">   * serialVersionUID to suppress a javac warning.</span></span>
<span class="line"><span style="color:#6A737D">   */</span></span>
<span class="line"><span style="color:#F97583">  private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#F97583"> long</span><span style="color:#E1E4E8"> serialVersionUID </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 6138294804551838833L</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /** Thread this worker is running in.  Null if factory fails. */</span></span>
<span class="line"><span style="color:#F97583">  final</span><span style="color:#E1E4E8"> Thread thread;</span></span>
<span class="line"><span style="color:#6A737D">  /** Initial task to run.  Possibly null. */</span></span>
<span class="line"><span style="color:#E1E4E8">  Runnable firstTask;</span></span>
<span class="line"><span style="color:#6A737D">  /** Per-thread task counter */</span></span>
<span class="line"><span style="color:#F97583">  volatile</span><span style="color:#F97583"> long</span><span style="color:#E1E4E8"> completedTasks;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // TODO: switch to AbstractQueuedLongSynchronizer and move</span></span>
<span class="line"><span style="color:#6A737D">  // completedTasks into the lock word.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /**</span></span>
<span class="line"><span style="color:#6A737D">   * Creates with given first task and thread from ThreadFactory.</span></span>
<span class="line"><span style="color:#6A737D">   * </span><span style="color:#F97583">@param</span><span style="color:#FFAB70"> firstTask</span><span style="color:#6A737D"> the first task (null if none)</span></span>
<span class="line"><span style="color:#6A737D">   */</span></span>
<span class="line"><span style="color:#B392F0">  Worker</span><span style="color:#E1E4E8">(Runnable </span><span style="color:#FFAB70">firstTask</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    setState</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// inhibit interrupts until runWorker</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.firstTask </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> firstTask;</span></span>
<span class="line"><span style="color:#6A737D">    // 创建 worker 线程</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.thread </span><span style="color:#F97583">=</span><span style="color:#B392F0"> getThreadFactory</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">newThread</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /** Delegates main run loop to outer runWorker. */</span></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> run</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">    runWorker</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // Lock methods</span></span>
<span class="line"><span style="color:#6A737D">  //</span></span>
<span class="line"><span style="color:#6A737D">  // The value 0 represents the unlocked state.</span></span>
<span class="line"><span style="color:#6A737D">  // The value 1 represents the locked state.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  private</span><span style="color:#F97583"> boolean</span><span style="color:#B392F0"> isHeldExclusively</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> getState</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  private</span><span style="color:#F97583"> boolean</span><span style="color:#B392F0"> tryAcquire</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#FFAB70"> unused</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">compareAndSetState</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)) {</span></span>
<span class="line"><span style="color:#B392F0">      setExclusiveOwnerThread</span><span style="color:#E1E4E8">(Thread.</span><span style="color:#B392F0">currentThread</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  private</span><span style="color:#F97583"> boolean</span><span style="color:#B392F0"> tryRelease</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#FFAB70"> unused</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    setExclusiveOwnerThread</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">    setState</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> lock</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">    acquire</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#F97583"> boolean</span><span style="color:#B392F0"> tryLock</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> tryAcquire</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> unlock</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">    release</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  public</span><span style="color:#F97583"> boolean</span><span style="color:#B392F0"> isLocked</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#B392F0"> isHeldExclusively</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  void</span><span style="color:#B392F0"> interruptIfStarted</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">    Thread t;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">getState</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">&gt;=</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583"> &amp;&amp;</span><span style="color:#E1E4E8"> (t </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> thread) </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> null</span><span style="color:#F97583"> &amp;&amp;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">t.</span><span style="color:#B392F0">isInterrupted</span><span style="color:#E1E4E8">()) {</span></span>
<span class="line"><span style="color:#F97583">      try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        t.</span><span style="color:#B392F0">interrupt</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (SecurityException </span><span style="color:#FFAB70">ignore</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">final</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> runWorker</span><span style="color:#E1E4E8">(Worker w) {</span></span>
<span class="line"><span style="color:#6A737D">    // 获取当前线程</span></span>
<span class="line"><span style="color:#E1E4E8">    Thread wt </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Thread.</span><span style="color:#B392F0">currentThread</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">    // 获取任务</span></span>
<span class="line"><span style="color:#E1E4E8">    Runnable task </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> w.firstTask;</span></span>
<span class="line"><span style="color:#E1E4E8">    w.firstTask </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    w.</span><span style="color:#B392F0">unlock</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// allow interrupts</span></span>
<span class="line"><span style="color:#F97583">    boolean</span><span style="color:#E1E4E8"> completedAbruptly </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        // 任务不为空 执行任务 如果任务为空 通过getTask()从阻塞队列中获取任务</span></span>
<span class="line"><span style="color:#F97583">        while</span><span style="color:#E1E4E8"> (task </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> null</span><span style="color:#F97583"> ||</span><span style="color:#E1E4E8"> (task </span><span style="color:#F97583">=</span><span style="color:#B392F0"> getTask</span><span style="color:#E1E4E8">()) </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">            // 加锁 避免被 SHUTDOWN 任务也不会中断</span></span>
<span class="line"><span style="color:#E1E4E8">            w.</span><span style="color:#B392F0">lock</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">            // 如果线程池状态大于等于STOP,请确保线程被中断;如果没有,请确保线程没有中断。这需要在第二种情况下重新检查,以处理关闭在清除中断时无竞争</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> ((</span><span style="color:#B392F0">runStateAtLeast</span><span style="color:#E1E4E8">(ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">(), STOP) </span><span style="color:#F97583">||</span></span>
<span class="line"><span style="color:#E1E4E8">                 (Thread.</span><span style="color:#B392F0">interrupted</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">&amp;&amp;</span></span>
<span class="line"><span style="color:#B392F0">                  runStateAtLeast</span><span style="color:#E1E4E8">(ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">(), STOP))) </span><span style="color:#F97583">&amp;&amp;</span></span>
<span class="line"><span style="color:#F97583">                !</span><span style="color:#E1E4E8">wt.</span><span style="color:#B392F0">isInterrupted</span><span style="color:#E1E4E8">())</span></span>
<span class="line"><span style="color:#6A737D">                // 中断</span></span>
<span class="line"><span style="color:#E1E4E8">                wt.</span><span style="color:#B392F0">interrupt</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">            try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">                // 执行任务前的操作</span></span>
<span class="line"><span style="color:#B392F0">                beforeExecute</span><span style="color:#E1E4E8">(wt, task);</span></span>
<span class="line"><span style="color:#F97583">                try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">                    task.</span><span style="color:#B392F0">run</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">                    afterExecute</span><span style="color:#E1E4E8">(task, </span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">                } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (Throwable </span><span style="color:#FFAB70">ex</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">                    // 执行任务后的操作</span></span>
<span class="line"><span style="color:#B392F0">                    afterExecute</span><span style="color:#E1E4E8">(task, ex);</span></span>
<span class="line"><span style="color:#F97583">                    throw</span><span style="color:#E1E4E8"> ex;</span></span>
<span class="line"><span style="color:#E1E4E8">                }</span></span>
<span class="line"><span style="color:#E1E4E8">            } </span><span style="color:#F97583">finally</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">                task </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">                w.completedTasks</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">                w.</span><span style="color:#B392F0">unlock</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">        completedAbruptly </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">finally</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">        processWorkerExit</span><span style="color:#E1E4E8">(w, completedAbruptly);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<h2 id="面试须知">面试须知</h2>
<h3 id="java-中如何停止线程">Java 中如何停止线程</h3>
<p>Java中有以下三种方法可以终止正在运行的线程:</p>
<ol>
<li>使用退出标志,使线程正常退出,也就是当 run() 方法完成后线程中止。这种方法需要在循环中检查标志位是否为 true,如果为 false,则跳出循环,结束线程。</li>
<li>使用 stop() 方法强行终止线程,但是不推荐使用这个方法,该方法已被弃用。这个方法会导致一些清理性的工作得不到完成,如文件,数据库等的关闭,以及数据不一致的问题。</li>
<li>使用 interrupt() 方法中断线程。这个方法会在当前线程中打一个停止的标记,并不是真的停止线程。因此需要在线程中判断是否被中断,并增加相应的中断处理代码。如果线程在 sleep() 或 wait() 等操作时被中断,会抛出 InterruptedException 异常。</li>
</ol>
<h4 id="使用标记位中止线程">使用标记位中止线程</h4>
<p>使用退出标志,使线程正常退出,也就是当 run() 方法完成后线程中止,是一种比较简单而安全的方法。这种方法需要在循环中检查标志位是否为 true,如果为 false,则跳出循环,结束线程。这样可以保证线程的资源正确释放,不会导致数据不一致或其他异常问题。</p>
<p>例如,下面的代码展示了一个使用退出标志的线程类:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> ServerThread</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">    //volatile修饰符用来保证其它线程读取的总是该变量的最新的值</span></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> volatile</span><span style="color:#F97583"> boolean</span><span style="color:#E1E4E8"> exit </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    @</span><span style="color:#F97583">Override</span></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> run</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">        ServerSocket serverSocket </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> ServerSocket</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">8080</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">        while</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">exit) {</span></span>
<span class="line"><span style="color:#E1E4E8">            serverSocket.</span><span style="color:#B392F0">accept</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">//阻塞等待客户端消息</span></span>
<span class="line"><span style="color:#6A737D">            //do something</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>在主方法中,可以通过修改标志位来控制线程的退出:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> static</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">String</span><span style="color:#E1E4E8">[] args) {</span></span>
<span class="line"><span style="color:#E1E4E8">    ServerThread t </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> ServerThread</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    t.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">    //do something else</span></span>
<span class="line"><span style="color:#E1E4E8">    t.exit </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">//修改标志位,退出线程</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>这种方法的优点是简单易懂,缺点是需要在循环中不断检查标志位,可能会影响性能。另外,如果线程在 sleep() 或 wait() 等操作时被设置为退出标志,它也不会立即响应,而是要等到阻塞状态结束后才能检查标志位并退出。</p>
<h4 id="使用-stop-方法强行终止线程">使用 stop() 方法强行终止线程</h4>
<p>使用 stop() 方法强行终止线程,是一种不推荐使用的方法,因为它会导致一些严重的问题。stop() 方法会立即终止线程,不管它是否在执行一些重要的操作,如关闭文件,释放锁,更新数据库等。这样会导致资源泄露,数据不一致,或者其他异常错误。</p>
<p>stop() 方法会立即释放该线程所持有的所有的锁,导致数据得不到同步,出现数据不一致的问题。例如,如果一个线程在修改一个对象的两个属性时被 stop() 了,那么可能只修改了一个属性,而另一个属性还是原来的值。这样就造成了对象的状态不一致。</p>
<p>例如,下面的代码展示了一个使用 stop() 方法的线程类:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> MyThread</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    @</span><span style="color:#F97583">Override</span></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> run</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">            FileWriter fw </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> FileWriter</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;test.txt&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">            fw.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Hello, world!&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">            Thread.</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1000</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">//模拟耗时操作</span></span>
<span class="line"><span style="color:#E1E4E8">            fw.</span><span style="color:#B392F0">close</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">//关闭文件</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (Exception </span><span style="color:#FFAB70">e</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">            e.</span><span style="color:#B392F0">printStackTrace</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>在主方法中,可以通过调用 stop() 方法来强行终止线程:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> static</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">String</span><span style="color:#E1E4E8">[] args) {</span></span>
<span class="line"><span style="color:#E1E4E8">    MyThread t </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> MyThread</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    t.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">    //do something else</span></span>
<span class="line"><span style="color:#E1E4E8">    t.</span><span style="color:#B392F0">stop</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">//强行终止线程</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>这种方法的缺点是很明显的,如果在关闭文件之前调用了 stop() 方法,那么文件就不会被正确关闭,可能会造成数据丢失或损坏。而且,stop() 方法会抛出 ThreadDeath 异常,如果没有捕获处理这个异常,那么它会向上层传递,可能会影响其他线程或程序的正常运行 。因此,使用 stop() 方法强行终止线程是一种<strong>非常危险而不负责任</strong>的做法,应该尽量避免使用。</p>
<h4 id="使用interrupt-方法中断线程">使用interrupt() 方法中断线程</h4>
<p><code>Thread.interrupt()</code>它能帮助我们在一个线程中断另一个线程。尽管它被命名为”interrupt”,但实际上它并不会立即停止一个线程的执行,而是设置一个中断标志,表示这个线程已经被中断。它的具体行为取决于被中断线程当前的状态以及如何响应中断。</p>
<p><code>interrupt</code>是<code>Thread</code>对象一个内部字段,用来表示它的中断状态。这个字段是由Java虚拟机(JVM)管理的,对应用程序代码是不可见的。</p>
<p>以下是有关<code>Thread.interrupt()</code>的一些重要事项:</p>
<ol>
<li><strong>对于非阻塞状态的线程</strong>: 如果线程处于运行状态,并且没有执行任何阻塞操作,那么调用<code>interrupt()</code>方法只会设置线程的中断状态,并不会影响线程的继续执行。线程需要自己检查这个中断状态,并决定是否停止执行。常见的检查方式包括调用<code>Thread.interrupted()</code>(这会清除中断状态)或者<code>Thread.currentThread().isInterrupted()</code>(不会清除中断状态)。</li>
<li><strong>对于阻塞状态的线程</strong>: 如果线程处于阻塞状态,如调用了<code>Object.wait()</code>, <code>Thread.join()</code>或者<code>Thread.sleep()</code>方法,那么线程会立即抛出<code>InterruptedException</code>,并且清除中断状态。</li>
<li><strong>对于已经停止的线程</strong>: 如果线程已经停止,那么调用<code>interrupt()</code>方法不会有任何影响。</li>
</ol>
<p><code>interrupt()</code>方法为我们提供了一种通用的,协作式的线程停止机制。它允许被中断的线程决定如何处理中断请求,可以立即停止,也可以忽略中断,或者继续执行一段时间然后再停止。</p>
<p>以下是一个使用<code>interrupt()</code>方法的例子:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#E1E4E8">Thread t </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">Thread.</span><span style="color:#B392F0">currentThread</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">isInterrupted</span><span style="color:#E1E4E8">()) {</span></span>
<span class="line"><span style="color:#6A737D">        // 执行任务</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">t.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// 在另一个线程中中断t线程</span></span>
<span class="line"><span style="color:#E1E4E8">t.</span><span style="color:#B392F0">interrupt</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span></code></pre> </div> 
<p>这个例子中,线程<code>t</code>会一直执行,直到它的中断状态被设置。这是通过检查<code>Thread.currentThread().isInterrupted()</code>实现的。当<code>t.interrupt()</code>被调用时,线程<code>t</code>的中断状态被设置,因此线程将退出循环并结束执行。</p>
<p>需要注意的是,如果线程在响应中断时需要执行一些清理工作,或者需要抛出一个异常来通知上游代码,那么就需要在捕获<code>InterruptedException</code>后,手动再次设置中断标志。这是因为当<code>InterruptedException</code>被抛出时,中断状态会被清除。例如:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">while</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">Thread.</span><span style="color:#B392F0">currentThread</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">isInterrupted</span><span style="color:#E1E4E8">()) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        // 执行可能抛出InterruptedException的任务</span></span>
<span class="line"><span style="color:#E1E4E8">        Thread.</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1000</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (InterruptedException </span><span style="color:#FFAB70">e</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">        // 捕获InterruptedException后,再次设置中断标志</span></span>
<span class="line"><span style="color:#E1E4E8">        Thread.</span><span style="color:#B392F0">currentThread</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">interrupt</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<h3 id="守护线程和用户线程有什么区别">守护线程和用户线程有什么区别</h3>
<ul>
<li>用户(User)线程: 运行在前台,执行具体的任务,如程序的主线程,连接网络的子线程等都是用户线程。</li>
<li>守护(Darmon)线程: 运行在后台,为其他前台线程服务。也可以说守护线程是JVM中非守护线程的”佣人”。一旦所有用户线程都结束运行,守护线程会随JVM一起结束工作。</li>
</ul>
<p>main函数所在的线程就是一个用户线程,main函数启动的同时在JVM内部同时启动了好多守护线程,比如垃圾回收线程。比较明显的区别之一就是用户线程结束,JVM退出,不管这个时候有没有守护线程运行。而守护线程不会影响JVM的退出。</p>
<h4 id="注意事项">注意事项</h4>
<ol>
<li>setDaemon(true)必须在start()方法前执行,否则会抛出 IllegalThreadStateException 异常。</li>
<li>在守护线程中产生的新线程也是守护线程。</li>
<li>不是所有的任务都可以分配给守护线程来执行,比如读写操作或者计算逻辑。</li>
<li>守护(Darmon)线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面说过了一旦所有用户线程都结束运行,守护线程会随JVM一起结束工作,所有守护(Daemon)线程中的finally 语句块可能无法被执行。</li>
</ol>
<h3 id="java-中-wait-和-sleep-方法的区别">Java 中 wait 和 sleep 方法的区别</h3>
<p>sleep 方法和 wait 方法都是用来将线程进入休眠状态的,并且 sleep 和 wait 方法都可以响应 interrupt 中断,也就是线程在休眠的过程中,如果收到中断信号,都可以进行响应并中断,且都可以抛出 InterruptedException 异常,那 sleep 和 wait 有什么区别呢?接下来,我们一起来看。</p>
<h4 id="区别一-语法使用不同">区别一: 语法使用不同</h4>
<p>wait 方法必须配合<code>synchronized</code>一起使用,不然在运行时就会抛出 IllegalMonitorStateException 的异常。wait 方法会将持有锁的线程从owner 扔到 WaitSet 集合中,这个操作是在修改 ObjectMonitor 对象,如果没有持有 synchronized 锁的话,是无法操作 ObjectMonitor 对象的。</p>
<p>而 sleep 可以单独使用,无需配合 synchronized 一起使用。</p>
<h4 id="区别二-所属类不同">区别二: 所属类不同</h4>
<p>wait 方法属于 Object 类的方法,而 sleep 属于 Thread 类的方法</p>
<h4 id="区别三-唤醒方式不同">区别三: 唤醒方式不同</h4>
<p>sleep 方法必须要传递一个超时时间的参数,且过了超时时间之后,线程会自动唤醒。而 wait 方法可以不传递任何参数,不传递任何参数时表示永久休眠,直到另一个线程调用了 notify 或 notifyAll 之后,休眠的线程才能被唤醒。也就是说 <strong>sleep 方法具有主动唤醒功能,而不传递任何参数的 wait 方法只能被动的被唤醒</strong>。</p>
<h4 id="区别四-释放锁资源不同">区别四: 释放锁资源不同</h4>
<p><strong>wait 方法会主动的释放锁,而 sleep 方法则不会</strong>。</p>
<h4 id="区别五-线程进入状态不同">区别五: 线程进入状态不同</h4>
<p>调用 sleep 方法线程会进入 TIMED_WAITING 有时限等待状态,而调用无参数的 wait 方法,线程会进入 WAITING 无时限等待状态**。**</p>
<p>sleep 和 wait 都可以让线程进入休眠状态,并且它们都可以响应 interrupt 中断,但二者的区别主要体现在: 语法使用不同,所属类不同,唤醒方式不同,释放锁不同和线程进入的状态不同。</p>
<h3 id="并发编程的三大特性">并发编程的三大特性</h3>
<h4 id="原子性">原子性</h4>
<p>JMM(Java Memory Model)。不同的硬件和不同的操作系统在内存上的操作有一定差异的,Java 为了解决相同代码在不同操作系统上出现的各种问题,用 JMM 屏蔽掉各种硬件和操作系统带来的差异。让 Java 的并发编程可以做到跨平台。</p>
<p>JMM 规定所有变量都会存储在主内存中,在操作的时候,需要从主内存中复制一份到线程内存(CPU 内存),在线程内部做计算,<strong>然后再写回主内存中(不一定)。</strong></p>
<p>原子性的定义: 原子性指一个操作是不可分割的,不可中断的,一个线程在执行时,另一个线程不会影响到他。</p>
<p>保证并发编程的原子性</p>
<ul>
<li>
<p>synchronized</p>
<p>可以在方法上追加 synchronized 关键字或采用同步代码块的形式保证原子性。synchronized 可以让多线程同时操作临界资源,同一个时间点,只会有一个线程操作临界资源。</p>
</li>
<li>
<p>cas</p>
<p>compare and swap 也就是比较和交换,它是一条 CPU 的并发原语。它在替换内存中某个位置的值时,首先查看内存中的值与预期的值是否一致,如果一致,执行替换操作。这个操作是一个原子性操作。Java 中基于Unsafe 的类提供了对 cas 操作的方法,jvm 会帮我们将方法实现 cas 汇编指令。但是要清楚,cas 只是比较和交换,在获取原值的这个操作上,需要自己实现。</p>
</li>
<li>
<p>lock</p>
<p>lock 锁是JDK1.5 由Doug lea 研发的,它的性能相比 synchronized 在JDK1.5 的时期,性能好了很多,但是在 JDK1.6 优化之后,性能相差不大,但是如果设置并发比较多时,推荐 ReentrantLock 锁,性能会更好。</p>
</li>
<li>
<p>ThreadLocal</p>
<p>ThreadLocal 保证原子性的操作,是不让多线程去操作临界资源,让每个线程去操作属于自己的数据。</p>
</li>
</ul>
<h4 id="可见性">可见性</h4>
<p>可见性问题是基于 CPU 位置出现的,CPU 处理速度非常快,相对 CPU 来说,去主内存获取数据这个事情太慢了,CPU 就提供了 L1,L2,L3 的三级缓存,每次去主内存拿完数据后,就会存储到 CPU 的三级缓存,每次去三级缓存中取数据,效率肯定会提升。</p>
<p>这就带来了问题,现在 CPU 都是多核的,每个线程的工作内存(CPU 三级缓存)都是独立的,会告知每个线程中修改时,只该自己的工作内存,没有及时的同步到主内存中,导致数据不一致问题。</p>
<p>解决可见性的方式</p>
<ul>
<li>
<p>volatile</p>
<p>volatile 是个关键字,用来修饰成员变量。如果属性被 volatile 修饰,相当于会告诉 CPU,对当前属性的操作,不使用 CPU 三级缓存,必须去和主内存进行操作。</p>
<p>volatile 的内存语义</p>
<ul>
<li>volatile 属性被写: 当写一个 volatile 变量,JMM 会将当前线程对应的CPU 缓存及时的刷新到主内存中。</li>
<li>volatile 属性被读: 当读一个 volatile 变量,JMM 会将对应的 CPU 缓存中的内存设置为无效,必须去主内存中读取共享变量。</li>
</ul>
<p>其实加了 volatile 就是告知CPU,对当前属性的读写操作,不使用 CPU 缓存,加了 volatile 修饰的属性,会在转为汇编之后,追加一个 lock 的前缀,CPU 执行这个指令时,如果带有 lock 前缀会做两个事情:</p>
<ul>
<li>将当前处理器缓存行的数据写回到主内存</li>
<li>这个写回的过程,在其他CPU 内核的缓存中,直接无效</li>
</ul>
</li>
<li>
<p>synchronized</p>
<p>synchronized 也是可以解决可见性问题的,synchronized 的内存语义。</p>
<p>如果涉及到了 synchronized 的同步代码块或者同步方法,获取锁资源之后,将内存获取的变量在 CPU 缓存中删除,必须去主内存中重新拿数据,而且在释放锁之后,会立即将 CPU 缓存中的数据同步到主内存中。</p>
</li>
<li>
<p>lock</p>
<p>lock 锁保证可见性的方式和 synchronized 完全不同,synchronized 基于它的内存语义,在获取锁和释放锁的时候,对 CPU 缓存做同步到主内存的操作。</p>
<p>lock 锁是基于 volatile 实现的,lock 锁内部在进行加锁和释放锁的时候,会对一个 volatile 修饰的 state 属性进行加减操作。</p>
<p>如果对 volatile 修饰的属性进行写操作,CPU 会执行带有 lock 前缀的指令,CPU 会将修改的数据,从 CPU 缓存立即同步到主内存中,同时也会将其他属性立即同步到主内存中,还会将其他 CPU 缓存行中的这个数据设置为无效,必须从主内存中拉取。</p>
</li>
<li>
<p>final</p>
<p>final 修饰的属性,在运行期间是不允许被修改的,这样一来就间接性的保证了可见性,所有多线程读取 final 属性,值肯定是一样的。</p>
<p>final 并不是说每次取数据从主内存读取,他没有这个必要,而且 final 和 volatile 不可以同时修饰一个属性。</p>
<p>final 修饰的属性已经不允许再次被写了,而 volatile 是保证每次读写操作去内存中读取,并且 volatile 会影响一定的性能,就不需要同时修饰。</p>
</li>
</ul>
<h4 id="有序性">有序性</h4>
<p>所谓有序性是指程序代码在执行过程中先后顺序,由于 Java 在编译器以及运行期的优化,导致了代码的执行顺序未必就是开发者编写代码的顺序,比如</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">int</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#E1E4E8"> y </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">x</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">y </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 20</span></span>
<span class="line"></span></code></pre> </div> 
<p>上面这段代码定义了两个 int 类型的变量 x 和 y,对 x 进行自增操作,对 y 进行赋值操作,从编写程序的角度看上面代码肯定是顺序执行下去的,但是 JVM 真正地运行这段代码的时候未必会是这样的顺序,比如 y = 20 语句有可能会在 x++ 语句的前面执行,这种情况就是通常所说的指令重排。</p>
<p>一般来说,处理器为了提高程序的运行效率,可能会对输入的代码指令做一定的优化,它不会百分百的保证代码的执行顺序严格按照编写代码中的顺序进行,但是它会保证程序的最终运算结果是编码时所期望的那样,比如上文中的 x++ 和 y = 20,不管它们的执行顺序如何,执行完上面四行代码之后得到的结果肯定都是 x =11,y = 20。</p>
<p>当然对指令的重排序要严格遵守指令之间的数据依赖关系,并不是可以任意进行重排序的,比如下面的代码片段。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">int</span><span style="color:#E1E4E8"> x </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#E1E4E8"> y </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">x</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">y</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">x</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span></code></pre> </div> 
<p>对于这段代码有可能它的执行顺序就是代码本身的顺序,有可能发生了重排序导致 int y=0 优于 int x =10 执行,但是绝对不能出现 y= x+1 优于 x++ 执行的执行情况,如果一个指令 x 在执行的过程中需要用到指令 y 的执行结果,那么处理器会保证指令 y 在指令 x 之前执行,这就好比 y = x+1 执行前肯定要先执行 x++ 一样。</p>
<p>在单线程情况下,无论怎样的重排序最终都会保证程序的执行结果和代码顺序执行结果完全一致的,但是在多线程情况下,如果有序性得不到保证,那么很有可能就会出现非常大的问题,比如下面的代码片段</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> boolean</span><span style="color:#E1E4E8"> initialized </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#E1E4E8"> Context context;</span></span>
<span class="line"><span style="color:#F97583">public</span><span style="color:#E1E4E8"> Context </span><span style="color:#B392F0">load</span><span style="color:#E1E4E8">(){</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">initialized){</span></span>
<span class="line"><span style="color:#E1E4E8">        context </span><span style="color:#F97583">=</span><span style="color:#B392F0"> loadContext</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        initialized </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> context;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>上面代码使用 boolean 变量 initialized 来控制 context 是否已经被加载过,在单线程下,无论怎样的重排序,最终返回给使用者的 context 都是可用的。如果在多线程的情况下发生了重排序,比如 context = loadContext 的执行顺序被重排序到 initialized = true; 的后面,那么这就是灾难性的。比如第一个线程首先判断 initialized = false,然后准备执行 loadContext 方法,但由于重排序,将 initialized 设置为 true,此时如果另外一个线程也执行 load 方法,发现此时 initialized 已经为 true 了,则返回一个还未被加载的 context,那么在程序的运行过程中势必会出现错误。</p>
<p>在 Java 中,.java 文件的内容会被编译,在执行前需要再次转为 CPU 可以识别的指令,CPU 在执行这些指令时,为了提升执行效率,在不影响最终结果的前提下(满足一些需求),会对指令进行重排。</p>
<p>指令乱序执行的原因,是为了尽可能的发挥 CPU 的性能。</p>
<p>Java 中的程序是乱序执行的。</p>
<p>保证有序性的方式</p>
<ul>
<li>
<p>as-if-serial</p>
</li>
<li>
<p>happens-before</p>
<p>具体规则</p>
<ol>
<li>单线程 happen-before 原则: 在同一个线程中,书写在前面的操作 happen-before 后面的操作。</li>
<li>锁的 happen-before 原则: 同一个所得 unlock 操作 happen-before 此锁的 lock 操作。</li>
<li>volatile 的 happens-before 原则: 对一个 volatile 变量的写操作 happen-before 对此变量的任何操作。</li>
<li>happen-before 的传递性原则: 如果 A 操作 happen-before B 操作,B 操作 happen-before C 操作,那么 A 操作 happen-before C 操作。</li>
<li>线程启动的 happen-before 原则: 同一个线程的 start 操作 happen-before 此线程的其他方法。</li>
<li>线程中断的 happen-before 原则: 对线程 interrupt 方法的调用 happen-before 被中断线程的检测到中断发送的代码。</li>
<li>线程终结的 happen-before 原则: 线程中所有的操作都 happen-before 线程的终止检测。</li>
<li>对象创建的 happen-before 原则: 一个对象的初始化完成先于他的finalize 方法调用。</li>
</ol>
<p>JMM 只有在不出现上述 8 中情况时,才不会触发指令重排效果。</p>
<p>不需要过分的关注 happen-before 原则,只需要可以写出线程安全的代码就可以了。</p>
</li>
<li>
<p>volatile</p>
<p>如果需要让程序对某一个属性的操作不出现指令重排,除了满足 happens-before 的原则外,还可以基于 volatile 修饰属性,从而对这个属性的操作,就不会出现指令重排的问题了。</p>
<p>volatile 如何实现的禁止指令重排?</p>
<p>内存屏障概念,将内存屏障看成一个指令。</p>
<p>会在两个操作之间,添加上一道指令,这个指令就可以避免上下执行的其他指令进行重排。</p>
</li>
</ul>
<h3 id="什么是-cas有什么优缺点">什么是 CAS?有什么优缺点</h3>
<p>在高并发的业务场景下,线程安全问题是必须考虑的,在JDK5之前,可以通过synchronized或Lock来保证同步,从而达到线程安全的目的。但synchronized或Lock方案属于互斥锁的方案,比较重量级,加锁,释放锁都会引起性能损耗问题。</p>
<p>而在某些场景下,我们是可以通过JUC提供的CAS机制实现无锁的解决方案,或者说是它基于类似于乐观锁的方案,来达到非阻塞同步的方式保证线程安全。</p>
<h4 id="什么是-cas">什么是 CAS</h4>
<p><code>CAS</code>是<code>Compare And Swap</code>的缩写,直译就是<strong>比较并交换</strong>。CAS是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令,这个指令会对内存中的共享数据做原子的读写操作。其作用是让CPU比较内存中某个值是否和预期的值相同,如果相同则将这个值更新为新值,不相同则不做更新。</p>
<p>本质上来讲CAS是一种无锁的解决方案,也是一种基于乐观锁的操作,可以保证在多线程并发中保障共享资源的原子性操作,相对于synchronized或Lock来说,是一种轻量级的实现方案。</p>
<p>Java中大量使用了CAS机制来实现多线程下数据更新的原子化操作,比如AtomicInteger,CurrentHashMap当中都有CAS的应用。但Java中并没有直接实现CAS,CAS相关的实现是借助<code>C/C++</code>调用CPU指令来实现的,效率很高,但Java代码需通过JNI才能调用。比如,Unsafe类提供的CAS方法(如compareAndSwapXXX)底层实现即为CPU指令cmpxchg。</p>
<h4 id="cas-的基本流程">CAS 的基本流程</h4>
<p><img src="https://cdn.jsdelivr.net/gh/chou403/pic-md@main//img/202402281131100.png" alt="image-20230825103445318"/></p>
<p>在上图中涉及到三个值的比较和操作: 修改之前获取的(待修改)值A,业务逻辑计算的新值B,以及待修改值对应的内存位置的C。</p>
<p>整个处理流程中,假设内存中存在一个变量i,它在内存中对应的值是A(第一次读取),此时经过业务处理之后,要把它更新成B,那么在更新之前会再读取一下i现在的值C,如果在业务处理的过程中i的值并没有发生变化,也就是A和C相同,才会把i更新(交换)为新值B。如果A和C不相同,那说明在业务计算时,i的值发生了变化,则不更新(交换)成B。最后,CPU会将旧的数值返回。而上述的一系列操作由CPU指令来保证是原子的。</p>
<p>在《Java并发编程实践》中对CAS进行了更加通俗的描述: 我认为原有的值应该是什么,如果是,则将原有的值更新为新值,否则不做修改,并告诉我原来的值是多少。</p>
<p>在上述路程中,我们可以很清晰的看到乐观锁的思路,而且这期间并没有使用到锁。因此,相对于synchronized等悲观锁的实现,效率要高非常多。</p>
<h4 id="基于-cas-的-atomicinteger-使用">基于 CAS 的 AtomicInteger 使用</h4>
<p>关于CAS的实现,最经典最常用的当属AtomicInteger了,我们马上就来看一下AtomicInteger是如何利用CAS实现原子性操作的。为了形成更加鲜明的对比,先来看一下如果不使用CAS机制,想实现线程安全我们通常如何处理。</p>
<p>在没有使用CAS机制时,为了保证线程安全,基于synchronized的实现如下:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> ThreadSafeTest</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583"> public</span><span style="color:#F97583"> static</span><span style="color:#F97583"> volatile</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583"> public</span><span style="color:#F97583"> synchronized</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> increase</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">  i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8"> }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>至于上面的实例具体实现,这里不再展开,很多相关的文章专门进行讲解,我们只需要知道为了保证i++的原子操作,在increase方法上使用了重量级的锁synchronized,这会导致该方法的性能低下,所有调用该方法的操作都需要同步等待处理。</p>
<p>那么,如果采用基于CAS实现的AtomicInteger类,上述方法的实现便变得简单且轻量级了:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> ThreadSafeTest</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583"> private</span><span style="color:#F97583"> final</span><span style="color:#E1E4E8"> AtomicInteger counter </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> AtomicInteger</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583"> public</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> increase</span><span style="color:#E1E4E8">(){</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> counter.</span><span style="color:#B392F0">addAndGet</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8"> }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>之所以可以如此安全,便捷地来实现安全操作,便是由于AtomicInteger类采用了CAS机制。下面,我们就来了解一下AtomicInteger的功能及源码实现。</p>
<h4 id="cas-的-atomicinteger-类">CAS 的 AtomicInteger 类</h4>
<p><code>AtomicInteger</code>是java.util.concurrent.atomic 包下的一个原子类,该包下还有<code>AtomicBoolean</code>, <code>AtomicLong</code>,<code>AtomicLongArray</code>, <code>AtomicReference</code>等原子类,主要用于在高并发环境下,保证线程安全。</p>
<h4 id="atomicinteger常用api">AtomicInteger常用API</h4>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> get</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> 获取当前的值</span></span>
<span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> getAndSet</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> newValue)</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> 获取当前的值,并设置新的值</span></span>
<span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> getAndIncrement</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> 获取当前的值,并自增</span></span>
<span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> getAndDecrement</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> 获取当前的值,并自减</span></span>
<span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> getAndAdd</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> delta)</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> 获取当前的值,并加上预期的值</span></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> lazySet</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> newValue)</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> 最终会设置成newValue,使用lazySet设置值后,可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span>
<span class="line"></span></code></pre> </div> 
<p>上述方法中,getAndXXX格式的方法都实现了原子操作。具体的使用方法参考上面的addAndGet案例即可。</p>
<h4 id="atomicinteger-核心源码">AtomicInteger 核心源码</h4>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> AtomicInteger</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Number</span><span style="color:#F97583"> implements</span><span style="color:#E1E4E8"> java.io.</span><span style="color:#B392F0">Serializable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#E1E4E8"> Unsafe unsafe </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Unsafe.</span><span style="color:#B392F0">getUnsafe</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    private</span><span style="color:#F97583"> static</span><span style="color:#F97583"> final</span><span style="color:#F97583"> long</span><span style="color:#E1E4E8"> valueOffset;</span></span>
<span class="line"><span style="color:#F97583">    static</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">            // 用于获取value字段相对当前对象的&quot;起始地址&quot;的偏移量</span></span>
<span class="line"><span style="color:#E1E4E8">            valueOffset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> unsafe.</span><span style="color:#B392F0">objectFieldOffset</span><span style="color:#E1E4E8">(AtomicInteger.class.</span><span style="color:#B392F0">getDeclaredField</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;value&quot;</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (Exception </span><span style="color:#FFAB70">ex</span><span style="color:#E1E4E8">) { </span><span style="color:#F97583">throw</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">(ex); }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    private</span><span style="color:#F97583"> volatile</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> value;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    //返回当前值</span></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> get</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> value;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    //递增加detla</span></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> getAndAdd</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#FFAB70"> delta</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">        // 1,this: 当前的实例</span></span>
<span class="line"><span style="color:#6A737D">        // 2,valueOffset: value实例变量的偏移量</span></span>
<span class="line"><span style="color:#6A737D">        // 3,delta: 当前value要加上的数(value+delta)。</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> unsafe.</span><span style="color:#B392F0">getAndAddInt</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">, valueOffset, delta);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    //递增加1</span></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> incrementAndGet</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> unsafe.</span><span style="color:#B392F0">getAndAddInt</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">, valueOffset, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">...</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>上述代码以AtomicInteger#incrementAndGet方法为例展示了AtomicInteger的基本实现。其中,在static静态代码块中,基于Unsafe类获取value字段相对当前对象的”起始地址”的偏移量,用于后续Unsafe类的处理。</p>
<p>在处理自增的原子操作时,使用的是Unsafe类中的getAndAddInt方法,CAS的实现便是由Unsafe类的该方法提供,从而保证自增操作的原子性。</p>
<p>同时,在AtomicInteger类中,可以看到value值通过volatile进行修饰,保证了该属性值的线程可见性。在多并发的情况下,一个线程的修改,可以保证到其他线程立马看到修改后的值。</p>
<p>通过源码可以看出, <code>AtomicInteger</code> 底层是通过<strong>volatile</strong>变量和CAS两者相结合来保证更新数据的原子性。其中关于Unsafe类对CAS的实现,我们下面详细介绍。</p>
<h4 id="cas-的工作原理">CAS 的工作原理</h4>
<p>CAS的实现原理简单来说就是由<strong>Unsafe类</strong>和其中的<strong>自旋锁</strong>来完成的,下面针对源代码来看一下这两块的内容。</p>
<h5 id="unsafe-类">Unsafe 类</h5>
<p>在AtomicInteger核心源码中,已经看到CAS的实现是通过Unsafe类来完成的,先来了解一下Unsafe类的作用。</p>
<p>sun.misc.Unsafe是JDK内部用的工具类。它通过暴露一些Java意义上说”不安全”的功能给Java层代码,来让JDK能够更多的使用Java代码来实现一些原本是平台相关的,需要使用native语言(例如C或C++)才可以实现的功能。该类不应该在JDK核心类库之外使用,这也是命名为Unsafe(不安全)的原因。</p>
<p>JVM的实现可以自由选择如何实现Java对象的”布局”,也就是在内存里Java对象的各个部分放在哪里,包括对象的实例字段和一些元数据之类。</p>
<p>Unsafe里关于对象字段访问的方法把对象布局抽象出来,它提供了objectFieldOffset()方法用于获取某个字段相对Java对象的”起始地址”的偏移量,也提供了getInt,getLong,getObject之类的方法可以使用前面获取的偏移量来访问某个Java对象的某个字段。在AtomicInteger的static代码块中便使用了objectFieldOffset()方法。</p>
<p>Unsafe类的功能主要分为内存操作,CAS,Class相关,对象操作,数组相关,内存屏障,系统相关,线程调度等功能。这里我们只需要知道其功能即可,方便理解CAS的实现,注意不建议在日常开发中使用。</p>
<h5 id="unsafe-和-cas">Unsafe 和 CAS</h5>
<p>AtomicInteger调用了Unsafe#getAndAddInt方法:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> incrementAndGet</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> unsafe.</span><span style="color:#B392F0">getAndAddInt</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">, valueOffset, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>上述代码等于是AtomicInteger调用UnSafe类的CAS方法,JVM帮我们实现出汇编指令,从而实现原子操作。</p>
<p>在Unsafe中getAndAddInt方法实现如下:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> final</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> getAndAddInt</span><span style="color:#E1E4E8">(Object var1, </span><span style="color:#F97583">long</span><span style="color:#E1E4E8"> var2, </span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> var4) {</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> var5;</span></span>
<span class="line"><span style="color:#F97583">    do</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        var5 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">getIntVolatile</span><span style="color:#E1E4E8">(var1, var2);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">while</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">compareAndSwapInt</span><span style="color:#E1E4E8">(var1, var2, var5, var5 </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> var4));</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> var5;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>getAndAddInt方法有三个参数:</p>
<ul>
<li>第一个参数表示当前对象,也就是new的那个AtomicInteger对象;</li>
<li>第二个表示内存地址;</li>
<li>第三个表示自增步伐,在AtomicInteger#incrementAndGet中默认的自增步伐是1。</li>
</ul>
<p>getAndAddInt方法中,首先把当前对象主内存中的值赋给val5,然后进入while循环。判断当前对象此刻主内存中的值是否等于val5,如果是,就自增(交换值),否则继续循环,重新获取val5的值。</p>
<p>在上述逻辑中核心方法是compareAndSwapInt方法,它是一个native方法,这个方法汇编之后是CPU原语指令,原语指令是连续执行不会被打断的,所以可以保证原子性。</p>
<p>在getAndAddInt方法中还涉及到一个实现<strong>自旋锁</strong>。所谓的自旋,其实就是上面getAndAddInt方法中的do while循环操作。当预期值和主内存中的值不等时,就重新获取主内存中的值,这就是自旋。</p>
<p>这里我们可以看到CAS实现的一个缺点: 内部使用<strong>自旋</strong>的方式进行<strong>CAS</strong>更新(while循环进行CAS更新,如果更新失败,则循环再次重试)。如果长时间都不成功的话,就会造成CPU极大的开销。</p>
<p>另外,Unsafe类还支持了其他的CAS方法,比如<code>compareAndSwapObject</code>,<code>compareAndSwapInt</code>,<code>compareAndSwapLong</code>。</p>
<h4 id="cas-的缺点">CAS 的缺点</h4>
<p><code>CAS</code>高效地实现了原子性操作,但在以下三方面还存在着一些缺点:</p>
<ul>
<li>循环时间长,开销大;</li>
<li>只能保证一个共享变量的原子操作;</li>
<li>ABA问题;</li>
</ul>
<p>下面就这个三个问题详细讨论一下。</p>
<h5 id="循环时间长开销大">循环时间长开销大</h5>
<p>在分析Unsafe源代码的时候我们已经提到,在Unsafe的实现中使用了自旋锁的机制。在该环节如果<code>CAS</code>操作失败,就需要循环进行<code>CAS</code>操作(do while循环同时将期望值更新为最新的),如果长时间都不成功的话,那么会造成CPU极大的开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升。</p>
<h5 id="只能保证一个共享变量的原子操作">只能保证一个共享变量的原子操作</h5>
<p>在最初的实例中,可以看出是针对一个共享变量使用了CAS机制,可以保证原子性操作。但如果存在多个共享变量,或一整个代码块的逻辑需要保证线程安全,CAS就无法保证原子性操作了,此时就需要考虑采用加锁方式(悲观锁)保证原子性,或者有一个取巧的办法,把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p>
<h5 id="aba问题">ABA问题</h5>
<p>虽然使用CAS可以实现非阻塞式的原子性操作,但是会产生ABA问题,ABA问题出现的基本流程:</p>
<ul>
<li>进程P1在共享变量中读到值为A;</li>
<li>P1被抢占了,进程P2执行;</li>
<li>P2把共享变量里的值从A改成了B,再改回到A,此时被P1抢占;</li>
<li>P1回来看到共享变量里的值没有被改变,于是继续执行;</li>
</ul>
<p>虽然P1以为变量值没有改变,继续执行了,但是这个会引发一些潜在的问题。ABA问题最容易发生在lock free的算法中的,CAS首当其冲,因为CAS判断的是指针的地址。如果这个地址被重用了呢,问题就很大了(地址被重用是很经常发生的,一个内存分配后释放了,再分配,很有可能还是原来的地址)。</p>
<p>维基百科上给了一个形象的例子: 你拿着一个装满钱的手提箱在飞机场,此时过来了一个火辣性感的美女,然后她很暖昧地挑逗着你,并趁你不注意,把用一个一模一样的手提箱和你那装满钱的箱子调了个包,然后就离开了,你看到你的手提箱还在那,于是就提着手提箱去赶飞机去了。</p>
<p>ABA问题的解决思路就是使用版本号: 在变量前面追加上版本号,每次变量更新的时候把版本号加1,那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。</p>
<p>另外,从Java 1.5开始,JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用,并且检查当前标志是否等于预期标志,如果全部相等,则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h3 id="contended-注解有什么用">@Contended 注解有什么用</h3>
<p>@Contended是<a href="https://so.csdn.net/so/search?q=Java&spm=1001.2101.3001.7020">Java</a> 8中引入的一个注解,用于减少多线程环境下的”伪共享”现象,以提高程序的性能。</p>
<p>要理解@Contended的作用,首先要了解一下什么是伪共享(False Sharing)。</p>
<h4 id="什么是伪共享">什么是伪共享</h4>
<p>伪共享(False Sharing)是多线程环境中的一种现象,涉及到CPU的缓存机制和缓存行(Cache Line)。</p>
<p>现代CPU中,为了提高访问效率,通常会在CPU内部设计一种快速存储区域,称为缓存(Cache)。CPU在读写主内存中的数据时,会首先查看该数据是否已经在缓存中。如果在,就直接从缓存读取,避免了访问主内存的耗时;如果不在,则从主内存读取数据并放入缓存,以便下次访问。</p>
<p>缓存不是直接对单个字节进行操作的,而是以块(通常称为”缓存行”)为单位操作的。一个缓存行通常包含64字节的数据。</p>
<p>在多线程环境下,如果两个或更多的线程在同一时刻分别修改存储在同一缓存行的不同数据,那么CPU为了保证数据一致性,会使得其他线程必须等待一个线程修改完数据并写回主内存后,才能读取或者修改这个缓存行的数据。尽管这些线程可能实际上操作的是不同的变量,但由于它们位于同一缓存行,因此它们之间就会存在不必要的数据竞争,这就是伪共享。</p>
<p>伪共享会降低并发程序的性能,因为它会增加缓存的同步操作和主内存的访问。解决伪共享的一种方式是尽量让经常被并发访问的变量分布在不同的缓存行中,例如,可以通过增加无关的填充数据,或者利用诸如Java的@Contended注解等工具。</p>
<p>@Contended 是Java 8引入的一个注解,设计用于减少多线程环境下的伪共享(False Sharing)问题以提高程序性能。</p>
<p>伪共享是现代多核处理器中一个重要的性能瓶颈,它发生在多个处理器修改同一缓存行(Cache Line)中的不同数据时。缓存行是内存的基本单位,一般为64字节。当一个处理器读取主内存中的数据时,它会将整个缓存行(包含需要的数据)加载到本地缓存(L1,L2或L3缓存)中。如果另一个处理器修改了同一缓存行中的其他数据,那么原先加载到缓存中的数据就会变得无效,需要重新从主内存中加载。这会增加内存访问的延迟,降低程序性能。</p>
<p>@Contended注解可以标注在字段或者类上。它能使得被标注的字段在内存布局上尽可能地远离其他字段,使得被标注的字段或者类中的字段分布在不同的缓存行上,从而减少伪共享的发生。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> Foo</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    @</span><span style="color:#F97583">Contended</span></span>
<span class="line"><span style="color:#F97583">    long</span><span style="color:#E1E4E8"> x;</span></span>
<span class="line"><span style="color:#F97583">    long</span><span style="color:#E1E4E8"> y;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>在这里,x被@Contended注解标记,所以x和y可能会被分布在不同的缓存行上,这样如果多个线程并发访问x和y,就不会引发伪共享。</p>
<p>需要注意的是,@Contended是JDK的内部API,它在Java 8中引入,但在默认情况下是不开放的,要使用需要添加JVM参数-XX:-RestrictContended,并且在编译时需要使用—add-exports java.base/jdk.internal.vm.annotation=ALL-UNNAMED。此外,过度使用@Contended可能会浪费内存,因为它会导致大量的内存空间被用作填充以保持字段间的距离。所以在使用时需要谨慎权衡内存和性能的考虑。</p>
<h4 id="简单案例">简单案例</h4>
<p>在Java 8及以上版本中,@Contended注解是属于jdk的内部API,因此在正常情况下使用时需要打开开关-XX:-RestrictContended才能正常使用。同时需要注意的是,@Contended在JDK 9以后的版本中可能无法正常工作,因为JDK 9开始禁止使用Sun的内部API。</p>
<p>以下是一个@Contended注解的简单使用案例:</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> jdk.internal.vm.annotation.Contended;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> ContendedExample</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    @</span><span style="color:#F97583">Contended</span></span>
<span class="line"><span style="color:#F97583">    volatile</span><span style="color:#F97583"> long</span><span style="color:#E1E4E8"> value1 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0L</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    @</span><span style="color:#F97583">Contended</span></span>
<span class="line"><span style="color:#F97583">    volatile</span><span style="color:#F97583"> long</span><span style="color:#E1E4E8"> value2 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0L</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> increaseValue1</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">        value1</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> increaseValue2</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">        value2</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> static</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">String</span><span style="color:#E1E4E8">[] </span><span style="color:#FFAB70">args</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">        ContendedExample example </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> ContendedExample</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">        Thread thread1 </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&lt;</span><span style="color:#79B8FF"> 1000000</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">                example.</span><span style="color:#B392F0">increaseValue1</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">        });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">        Thread thread2 </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Thread</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">-&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&lt;</span><span style="color:#79B8FF"> 1000000</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">                example.</span><span style="color:#B392F0">increaseValue2</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">        });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">        thread1.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        thread2.</span><span style="color:#B392F0">start</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">            thread1.</span><span style="color:#B392F0">join</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">            thread2.</span><span style="color:#B392F0">join</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (InterruptedException </span><span style="color:#FFAB70">e</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">            e.</span><span style="color:#B392F0">printStackTrace</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">        System.out.</span><span style="color:#B392F0">println</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;value1: &quot;</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> example.value1);</span></span>
<span class="line"><span style="color:#E1E4E8">        System.out.</span><span style="color:#B392F0">println</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;value2: &quot;</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> example.value2);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>这个例子中定义了两个使用了@Contended注解的volatile长整型字段value1和value2。两个线程分别对这两个字段进行增加操作。因为这两个字段使用了@Contended注解,所以他们会被分布在不同的缓存行中,减少了因伪共享带来的性能问题。但由于伪共享的影响在实际运行中并不容易直接观察,所以这个例子主要展示了@Contended注解的使用方式,而不是实际效果。</p>
<p>@Contended 注解,就是将一个缓存行的后面 7 个位置,填充上 7 个没有意义的数据。</p>
<h3 id="threadlocal-的内存泄漏问题">ThreadLocal 的内存泄漏问题</h3>
<h4 id="threadlocal-实现原理">ThreadLocal 实现原理</h4>
<ul>
<li>每个 Thread 中都存储着一个成员变量,ThreadLocalMap</li>
<li>ThreadLocal 本身不存储数据,像是一个工具类,基于 ThreadLocal 去操作 ThreadLocalMap</li>
<li>ThreadLocalMap 本身就是基于 Entry[] 实现的,因为一个线程可以绑定多个 ThreadLocal,这样一来,可能需要存储多个数据,所以采用 Entry[] 的形式实现。</li>
<li>每个现有都自己独立的 ThreadLocalMap,再基于 ThreadLocal 对象本身作为 key,对 value 进行存取</li>
<li>ThreadLocalMap 的 key 是一个弱引用,弱引用的特点是,即便有若医用,再 GC 时,也必须被回收。这里是为了在 ThreadLocal 对象失去引用后,如果 key 的引用是强引用,会导致 ThreadLocal 对象无法被回收。</li>
</ul>
<h4 id="threadlocal-内存泄漏原因">ThreadLocal 内存泄漏原因</h4>
<ul>
<li>如果 ThreadLocal 引用丢失,key 因为弱引用会被 GC 回收掉,如果同时线程还没有被回收,就会导致内存泄漏,内存中的 value 无法被回收,同时也无法被获取到。</li>
<li>只需要在使用完毕 ThreadLocal 对象之后,及时的调用 remove 方法,移除 Entry 即可。</li>
</ul>
<h3 id="线程池为何要构建空任务的非核心线程">线程池为何要构建空任务的非核心线程</h3>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#6A737D">// 工作线程小于核心线程执行</span></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">workerCountOf</span><span style="color:#E1E4E8">(c) </span><span style="color:#F97583">&lt;</span><span style="color:#E1E4E8"> corePoolSize) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">addWorker</span><span style="color:#E1E4E8">(command, </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">))</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  c </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isRunning</span><span style="color:#E1E4E8">(c) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#E1E4E8"> workQueue.</span><span style="color:#B392F0">offer</span><span style="color:#E1E4E8">(command)) {</span></span>
<span class="line"><span style="color:#F97583">  int</span><span style="color:#E1E4E8"> recheck </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctl.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#B392F0"> isRunning</span><span style="color:#E1E4E8">(recheck) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#B392F0"> remove</span><span style="color:#E1E4E8">(command))</span></span>
<span class="line"><span style="color:#B392F0">    reject</span><span style="color:#E1E4E8">(command);</span></span>
<span class="line"><span style="color:#F97583">  else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">workerCountOf</span><span style="color:#E1E4E8">(recheck) </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#6A737D">    // 添加空任务</span></span>
<span class="line"><span style="color:#B392F0">    addWorker</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">false</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#B392F0">addWorker</span><span style="color:#E1E4E8">(command, </span><span style="color:#79B8FF">false</span><span style="color:#E1E4E8">))</span></span>
<span class="line"><span style="color:#B392F0">  reject</span><span style="color:#E1E4E8">(command);</span></span>
<span class="line"></span></code></pre> </div> 
<p>若是核心线程数设置的为0,我们第一次执行addWorker时,就会因为核心线程和工作线程都是0,不会执行第一块标红的区域,而是会执行第二块,而第二块是直接将任务添加到阻塞队列里面,此时是没有工作线程的,那阻塞队列里的任务由谁执行呢?所以在线程池的状态正常的情况下会添加一个空任务用于执行阻塞队列中的任务。</p>
<p>避免线程池出现工作队列有任务,但是没有工作线程处理。</p>
<p>线程池可以设置核心线程数是0个。这样,任务扔到阻塞队列,但是没有工作线程,这不凉凉了么。</p>
<p>线程池中的核心线程不是一定不会被回收,线程池中有一个属性,如果设置为true,核心线程也会被干掉。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#6A737D">/**</span></span>
<span class="line"><span style="color:#6A737D"> * If false (default), core threads stay alive even when idle.</span></span>
<span class="line"><span style="color:#6A737D"> * If true, core threads use keepAliveTime to time out waiting</span></span>
<span class="line"><span style="color:#6A737D"> * for work.</span></span>
<span class="line"><span style="color:#6A737D"> */</span></span>
<span class="line"><span style="color:#F97583">private</span><span style="color:#F97583"> volatile</span><span style="color:#F97583"> boolean</span><span style="color:#E1E4E8"> allowCoreThreadTimeOut;</span></span>
<span class="line"></span></code></pre> </div> 
<p>在线程池中,当工作队列已满且活动线程数小于最大线程数时,会创建非核心线程来执行任务。即使是空任务,也可能会被分配给非核心线程来执行。这是因为线程池的设计考虑到以下几个方面的因素:</p>
<ol>
<li><strong>任务处理的公平性</strong>:
空任务也被看作是一种任务,线程池需要公平地处理所有提交的任务。如果只有非空任务才会被分配给非核心线程,那么在任务队列中可能会积累大量的空任务,导致非核心线程一直处于空闲状态,而核心线程却忙于执行非空任务。</li>
<li><strong>响应时间的需求</strong>:
线程池旨在提供一种能够快速响应任务的机制。即使是空任务,也可以使线程池保持活跃状态,以便在有实际任务到来时能够立即分配线程进行执行,而不需要额外的线程创建开销。</li>
<li><strong>线程的复用性</strong>:
创建和销毁线程都需要一定的时间和资源开销。通过让非核心线程执行空任务,可以使线程池中的线程得到更好的复用,减少频繁地创建和销毁线程的开销。</li>
</ol>
<p>总的来说,为了保持任务处理的公平性,快速响应时间和线程的复用性,线程池会将空任务也分配给非核心线程执行。</p>
<p>需要注意的是,空任务并不会占用实际的计算资源,因此它们不会对系统的整体性能产生负面影响。但是,在使用线程池时,确保任务的提交是有意义且合理的,避免无谓的空任务提交。</p>
<h4 id="空任务">空任务</h4>
<p>空任务(Empty Task)指的是在线程池中提交的一个任务,其执行过程中不需要执行任何实际的操作或逻辑。空任务本身不包含需要执行的代码,或者说它的执行代码为空或者只是一个空的循环。</p>
<p>空任务可能是由于以下原因之一而产生:</p>
<ol>
<li><strong>任务队列的填充</strong>:
为了保持任务队列的饱满状态,或者为了占据队列中的位置以防止新任务被拒绝,可能会提交一些空任务。</li>
<li><strong>资源占用</strong>:
为了占用一定的系统资源或者保持线程池中的线程处于活跃状态,可能会提交一些空任务。</li>
</ol>
<p>空任务的实际意义相对较小,因为它们没有具体的业务逻辑或计算任务。在实际应用中,通常会提交具有实际意义的任务来利用线程池的并发执行能力。</p>
<p>需要注意的是,过多的空任务可能会占用线程池的资源,导致性能下降。因此,在使用线程池时,应该确保任务的提交是有意义的,避免无谓的空任务提交。</p>
<h3 id="线程池使用完毕为何必须shutdown">线程池使用完毕为何必须shutdown()</h3>
<p>线程池里面复用的是线程资源,而线程是系统资源的一种。所以关闭线程池是为了正确地终止线程池的运行并释放相关资源。下面是关闭线程池的重要原因:</p>
<ul>
<li>
<p>释放资源:</p>
<p>线程池内部会创建一定数量的线程以及其他相关资源,如线程队列,线程池管理器等。如果不及时关闭线程池,这些资源将一直占用系统资源,可能导致内存泄漏或资源浪费。</p>
</li>
<li>
<p>防止任务丢失:</p>
<p>线程池中可能还有未执行的任务,如果不关闭线程池,这些任务将无法得到执行。关闭线程池时,会等待所有已提交的任务执行完毕,确保任务不会丢失。</p>
</li>
<li>
<p>优雅终止:</p>
<p>关闭线程池可以让线程池中的线程正常执行完当前任务后停止,避免突然终止线程导致的资源释放不完整或状态不一致的问题。</p>
</li>
<li>
<p>避免程序阻塞:</p>
<p>在某些情况下,如果不关闭线程池,程序可能会一直等待线程池中的任务执行完毕,从而导致程序阻塞,无法继续执行后续的逻辑。</p>
</li>
</ul>
<p>因此,为了正确管理系统资源,避免任务丢失,保证程序的正常执行和避免阻塞,应当在不再需要线程池时及时关闭它。关闭线程池的一般做法是调用线程池的shutdown()方法,它会优雅地关闭线程池,等待已提交的任务执行完毕后才会终止线程池的运行。</p>
<!-- remove bg-neutral-200/30 --><div class="code-container"> <pre class="shiki shiki-themes code dark:shadow-2xl"><button aria-label="copy-button" class="copy-button rounded-md transition-all ease-in dark:text-gray-600 text-gray-400 hover:text-indigo-500 dark:hover:text-indigo-400 z-[2]"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path> <path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path> </svg></button><span class="check-span rounded-md transition-all ease-in opacity-0 text-green-600 dark:text-green-400"><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"> <path stroke="none" d="M0 0h24v24H0z" fill="none"></path> <path d="M5 12l5 5l10 -10"></path> </svg></span><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> shutdown</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  final</span><span style="color:#E1E4E8"> ReentrantLock mainLock </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.mainLock;</span></span>
<span class="line"><span style="color:#E1E4E8">  mainLock.</span><span style="color:#B392F0">lock</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">    // 权限检查</span></span>
<span class="line"><span style="color:#B392F0">    checkShutdownAccess</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">    // 设置当前线程池状态为 SHUTDOWN,如果已经是这个状态直接返回</span></span>
<span class="line"><span style="color:#B392F0">    advanceRunState</span><span style="color:#E1E4E8">(SHUTDOWN);</span></span>
<span class="line"><span style="color:#6A737D">    // 设置中断标准</span></span>
<span class="line"><span style="color:#B392F0">    interruptIdleWorkers</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    onShutdown</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// hook for ScheduledThreadPoolExecutor</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">finally</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    mainLock.</span><span style="color:#B392F0">unlock</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#6A737D">  // 尝试将状态变为 TERMINATED</span></span>
<span class="line"><span style="color:#B392F0">  tryTerminate</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre> </div> 
<p>shutdown()是线程池正常关闭的方法,它会先停止接收新的任务,然后等待已经提交的任务执行完毕后再停止。调用shutdown()后,线程池会逐渐停止,但不会立即停止。当线程池中的任务都执行完毕后,shutdown()会将所有的线程都关闭,这时线程池就终止了。</p>
<p>isShutdown()返回线程池是否已经调用过shutdown(),如果已经调用过,则返回true,否则返回false。</p>
<p>isTerminated()用于判断线程池中的所有任务是否已经执行完毕,并且所有线程都已经被关闭。如果是,则返回true,否则返回false。</p>
<p>awaitTermination()用于等待线程池中的任务执行完毕并关闭线程池。它会阻塞调用线程,直到线程池中的所有任务都执行完毕或者等待超时。该方法需要传入一个超时时间和时间单位,如果超时了,就会返回false,否则返回true。</p>
<p>shutdownNow()是强制关闭线程池的方法,它会尝试立即停止正在执行的任务,并返回等待执行的任务列表。调用shutdownNow()后,线程池会立即停止,但不保证所有正在执行的任务都能被停止。</p>
<p>需要注意的是,调用shutdownNow()会抛出InterruptedException异常,需要进行异常处理。并且,在使用shutdownNow()强制关闭线程池时,需要确保所有任务都能够正常停止,否则可能会导致任务数据丢失或其他问题。</p>
<p>为何必须 shutdown()?</p>
<p>首先,线程池执行线程时也是通过Thread对象的start()来启动线程,这种方式的线程本身就会占用一个虚拟机栈,而虚拟机栈在JVM中属于GC Roots。</p>
<p>根据可达性分析算法,这个线程就不可能被回收。一直占用JVM的内存资源。这样就会造成一个问题,线程池如果没有执行shutdown或shutdownnow。</p>
<p>那么构建的所有核心线程就永远不能被回收,这样就会造成内存泄漏问题。除了线程内存的泄漏还有另外一个问题,线程池启动线程是基于Worker内部的Thread去启动的,当执行t.start之后,它会执行worker的run方法,接着调用runworker方法,而runworker方法的传入的是this就是当前的worker对象。</p>
<p>那么可以这样理解,我启动一个线程还指向Worker对象。那么worker对象也是不能被回收的,同时worker对象是线程池的内部类,就会出现内部类都不能被回收,那外部类整个线程池也不能被回收。</p>
<h3 id="线程池的核心参数到底如何设置">线程池的核心参数到底如何设置</h3>
<h4 id="cpu-密集型和-io-密集型">CPU 密集型和 IO 密集型</h4>
<p>线程任务可以分为 CPU 密集型和 IO 密集型。(平时开发基本上都是 IO 密集型任务)</p>
<p>CPU 密集型任务的特点是进行大量的计算,消耗 CPU 资源,比如计算圆周率,视频高清解码等。这种任务操作都是比较耗时间的操作,任务越多花在任务切换的时间就越多,CPU 执行任务效率就越低。所以,应当减少线程的数量,CPU 密集型任务同时进行的数量应当等于 CPU 的核心数。</p>
<p>IO 密集型的任务的特点是涉及到网络(调用三方接口),磁盘 IO(文件操作)等。这类任务操作是 CPU 消耗很少,任务大部分时间都在等待 IO 操作完成(IO 的速度远低于 CPU 和内存的速度)。对于这种任务,任务越多,CPU 效率越高,但是也有限度。我们开发接口时,像调用别的应用接口,基本逻辑处理等,基本上都是 IO 密集型任务。</p>
<p>CPU 密集型尽量配置少的线程,核心线程配置: CPU 核数。而 IO 线程池应配置多的线程,核心线程配置: CPU 核数*2.这里 IO 密集型还有一种情况是线程易阻塞型,需要计算阻塞系数,核心线程配置: CPU 核数/1-阻塞系数(0.8-0.9 之间)。</p>
<h4 id="设计规则">设计规则</h4>
<p>线程池的使用难度不大,难度在于线程池的参数并不好配置。主要难点在于任务类型无法控制,比如任务有 CPU 密集型,IO 密集型,混合型。因为 IO 我们无法直接控制,所以很多时间按照一些书上提供的一些方法,是无法解决问题的。想调试出一个符合当前任务情况的核心参数,最好的方式就是测试。需要将项目部署到测试环境或者是沙箱环境中,结果各种压测得到一个相对符合的参数。如果每次修改项目都需要重新部署,成本太高了,此时可以实现一个动态监控以及修改线程池的方案。</p>
<p>因为线程池的核心参数无非就是:</p>
<ul>
<li>corePoolSize: 核心线程数</li>
<li>maximumPoolSize: 最大线程数</li>
<li>workQueue: 工作队列</li>
</ul>
<p>线程池中提供了获取核心信息的 get 方法,同时也提供了动态修改核心属性的 set 方法。</p>
<p>也可以采用一些开源项目提供的方式去监控和修改。 比如 hippo4j。</p> </div> <div class="mb-12 flex flex-wrap gap-2 gap-y-4 md:gap-5"> <a href="/tags/java" aria-label="java"> <!-- <span
		class="w-fit rounded-full bg-indigo-600 px-2 py-1 text-sm font-semibold text-white shadow dark:bg-indigo-900 dark:text-white md:px-5 md:py-2"
	> --> <span class="w-fit rounded-full px-2 py-1 text-sm font-semibold shadow dark:bg-indigo-900 dark:text-white md:px-5 md:py-2">
#java </span> </a><a href="/tags/thread" aria-label="thread"> <!-- <span
		class="w-fit rounded-full bg-indigo-600 px-2 py-1 text-sm font-semibold text-white shadow dark:bg-indigo-900 dark:text-white md:px-5 md:py-2"
	> --> <span class="w-fit rounded-full px-2 py-1 text-sm font-semibold shadow dark:bg-indigo-900 dark:text-white md:px-5 md:py-2">
#thread </span> </a> </div> <!-- related posts --> <footer> <h2 class="mb-6 text-lg font-bold dark:text-white">Related Posts</h2> <section class="flex flex-col md:flex-row sm:justify-between gap-8"> <div class="flex flex-wrap gap-2"> <div class="min-h-full"> <img src="/_astro/cat-25_2dcSSL.webp" class="h-16 w-16 rounded-full object-cover" alt="img of Single test coverage statistical principle" width="200" height="200" loading="lazy" decoding="async"> </div> <header class="flex items-center justify-center"> <a class="font-medium hover:underline" href="/post/zh-cn/interview/unittest/single-test-coverage-statistical-principle/"> 单测覆盖率是如何统计的?原理是什么? </a> </header> </div><div class="flex flex-wrap gap-2"> <div class="min-h-full"> <img src="/_astro/eightkun_ZWtkIv.webp" class="h-16 w-16 rounded-full object-cover" alt="img of How to unit test the JDBC layer" width="200" height="200" loading="lazy" decoding="async"> </div> <header class="flex items-center justify-center"> <a class="font-medium hover:underline" href="/post/zh-cn/interview/unittest/how-to-unit-test-the-jdbc-layer/"> 如何对JDBC这一层做单元测试 </a> </header> </div><div class="flex flex-wrap gap-2"> <div class="min-h-full"> <img src="/_astro/pexels-pixabay-531533_ZYDUp0.webp" class="h-16 w-16 rounded-full object-cover" alt="img of How to make a single test Mock" width="200" height="200" loading="lazy" decoding="async"> </div> <header class="flex items-center justify-center"> <a class="font-medium hover:underline" href="/post/zh-cn/interview/unittest/how-to-make-a-single-test-mock/"> 什么是Mock?怎么做单测的Mock? </a> </header> </div> </section> </footer> </article> </div>  </div> </article> <button aria-label="Back to Top" class="z-90 fixed bottom-8 end-4 flex h-10 w-10 translate-y-28 items-center justify-center rounded-full border-2 border-transparent bg-[#f8f9fa99] text-3xl opacity-0 transition-all duration-300 hover:border-zinc-400 data-[show=true]:translate-y-0 data-[show=true]:opacity-100 dark:border-slate-50/[0.06] dark:bg-slate-900/75 sm:end-8 sm:h-12 sm:w-12" data-show="false" id="to-top-btn" style="opacity: 1;--tw-translate-y: -26px;
		transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));"> <svg aria-hidden="true" class="h-6 w-6" fill="none" focusable="false" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <path d="M4.5 15.75l7.5-7.5 7.5 7.5" stroke-linecap="round" stroke-linejoin="round"></path> </svg> </button>  <footer class="flex h-28 w-full items-center justify-center border-t-2 px-16">
&copy; 2024 chou403 · Powered by &nbsp;<a href="https://astro.build" style="color:cornflowerblue;">Astro</a>&nbsp;& &nbsp;<a href="https://blog-template-gray.vercel.app" style="color:cornflowerblue;">OpenBlog</a> </footer> </main>    </body> </html>  <div> <div class="fixed inset-0 z-50 hidden" id="headlessui-dialog-:Rlb6:" role="dialog" aria-modal="true" data-headlessui-state="open"> <div class="fixed inset-0 bg-black/20 backdrop-blur-sm dark:bg-slate-900/80" id="" aria-hidden="true" data-headlessui-state="open"></div> <div class="relative w-80 max-w-[calc(100%-3rem)] bg-white p-6 dark:bg-slate-800" id="toc_content"> <button id="close-dialog-page" type="button" class="absolute right-5 top-5 z-10 flex h-8 w-8 items-center justify-center text-slate-500 hover:text-slate-600 dark:text-slate-400 dark:hover:text-slate-300" tabindex="0"><span class="sr-only">Close navigation</span> <svg viewBox="0 0 10 10" class="h-2.5 w-2.5 overflow-visible"> <path d="M0 0L10 10M10 0L0 10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path> </svg> </button> <nav class="h-[59rem] max-w-xs dark:text-black"> <h1 class="mb-3 text-2xl font-bold dark:text-white">On this page</h1> <ul class="sidebar flex flex-col gap-4 [text-wrap:balance]"> <li class="flex flex-col"> <a href="#java-中线程的状态" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> Java 中线程的状态 </a>  </li><li class="flex flex-col"> <a href="#threadpool" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> ThreadPool </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#jdk-提供的线程池" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> JDK 提供的线程池 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#newfixedthreadpool" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> newFixedThreadPool </a>  </li><li class="flex flex-col"> <a href="#newsinglethreadexecutor" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> newSingleThreadExecutor </a>  </li><li class="flex flex-col"> <a href="#newcachedthreadpool" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> newCachedThreadPool </a>  </li><li class="flex flex-col"> <a href="#newscheduledthreadpool" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> newScheduledThreadPool </a>  </li><li class="flex flex-col"> <a href="#newworkstealingpool" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> newWorkStealingPool </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#核心参数" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 核心参数 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#自定义线程池七大参数" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 自定义线程池七大参数 </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#线程池的状态" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 线程池的状态 </a>  </li><li class="flex flex-col"> <a href="#线程池执行流程" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 线程池执行流程 </a>  </li><li class="flex flex-col"> <a href="#woker" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> Woker </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#面试须知" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 面试须知 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#java-中如何停止线程" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> Java 中如何停止线程 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#使用标记位中止线程" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 使用标记位中止线程 </a>  </li><li class="flex flex-col"> <a href="#使用-stop-方法强行终止线程" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 使用 stop() 方法强行终止线程 </a>  </li><li class="flex flex-col"> <a href="#使用interrupt-方法中断线程" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 使用interrupt() 方法中断线程 </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#守护线程和用户线程有什么区别" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 守护线程和用户线程有什么区别 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#注意事项" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 注意事项 </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#java-中-wait-和-sleep-方法的区别" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> Java 中 wait 和 sleep 方法的区别 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#区别一-语法使用不同" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 区别一: 语法使用不同 </a>  </li><li class="flex flex-col"> <a href="#区别二-所属类不同" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 区别二: 所属类不同 </a>  </li><li class="flex flex-col"> <a href="#区别三-唤醒方式不同" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 区别三: 唤醒方式不同 </a>  </li><li class="flex flex-col"> <a href="#区别四-释放锁资源不同" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 区别四: 释放锁资源不同 </a>  </li><li class="flex flex-col"> <a href="#区别五-线程进入状态不同" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 区别五: 线程进入状态不同 </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#并发编程的三大特性" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 并发编程的三大特性 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#原子性" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 原子性 </a>  </li><li class="flex flex-col"> <a href="#可见性" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 可见性 </a>  </li><li class="flex flex-col"> <a href="#有序性" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 有序性 </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#什么是-cas有什么优缺点" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 什么是 CAS?有什么优缺点 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#什么是-cas" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 什么是 CAS </a>  </li><li class="flex flex-col"> <a href="#cas-的基本流程" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> CAS 的基本流程 </a>  </li><li class="flex flex-col"> <a href="#基于-cas-的-atomicinteger-使用" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 基于 CAS 的 AtomicInteger 使用 </a>  </li><li class="flex flex-col"> <a href="#cas-的-atomicinteger-类" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> CAS 的 AtomicInteger 类 </a>  </li><li class="flex flex-col"> <a href="#atomicinteger常用api" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> AtomicInteger常用API </a>  </li><li class="flex flex-col"> <a href="#atomicinteger-核心源码" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> AtomicInteger 核心源码 </a>  </li><li class="flex flex-col"> <a href="#cas-的工作原理" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> CAS 的工作原理 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#unsafe-类" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> Unsafe 类 </a>  </li><li class="flex flex-col"> <a href="#unsafe-和-cas" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> Unsafe 和 CAS </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#cas-的缺点" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> CAS 的缺点 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#循环时间长开销大" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 循环时间长开销大 </a>  </li><li class="flex flex-col"> <a href="#只能保证一个共享变量的原子操作" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 只能保证一个共享变量的原子操作 </a>  </li><li class="flex flex-col"> <a href="#aba问题" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> ABA问题 </a>  </li> </ul> </li> </ul> </li><li class="flex flex-col"> <a href="#contended-注解有什么用" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> @Contended 注解有什么用 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#什么是伪共享" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 什么是伪共享 </a>  </li><li class="flex flex-col"> <a href="#简单案例" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 简单案例 </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#threadlocal-的内存泄漏问题" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> ThreadLocal 的内存泄漏问题 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#threadlocal-实现原理" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> ThreadLocal 实现原理 </a>  </li><li class="flex flex-col"> <a href="#threadlocal-内存泄漏原因" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> ThreadLocal 内存泄漏原因 </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#线程池为何要构建空任务的非核心线程" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 线程池为何要构建空任务的非核心线程 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#空任务" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 空任务 </a>  </li> </ul> </li><li class="flex flex-col"> <a href="#线程池使用完毕为何必须shutdown" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 线程池使用完毕为何必须shutdown() </a>  </li><li class="flex flex-col"> <a href="#线程池的核心参数到底如何设置" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 线程池的核心参数到底如何设置 </a> <ul class="ml-3"> <li class="flex flex-col"> <a href="#cpu-密集型和-io-密集型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> CPU 密集型和 IO 密集型 </a>  </li><li class="flex flex-col"> <a href="#设计规则" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2"> 设计规则 </a>  </li> </ul> </li> </ul> </li> </ul> </nav> </div> </div> </div> 