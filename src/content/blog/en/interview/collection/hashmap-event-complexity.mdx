---
author: chou403
publishDate: 2024-06-14T09:00:23
updatedDate: 2024-08-09T14:46:11
title: HashMap 事件复杂度
draft: false
heroImage: /src/assets/images/eightkun.jpg
category: Interview
tags:
  - java
description: Hashmap 的时间复杂度是多少?如果出现hash 碰撞如何处理?hashmap 最极端的时间复杂度是多少?
---

## Hashmap 的时间复杂度是多少?如果出现hash 碰撞如何处理?hashmap 最极端的时间复杂度是多少?

在 Java 中,`HashMap` 是一个常用的数据结构,它的时间复杂度在大多数情况下都是非常高效的。然而,了解它的时间复杂度以及如何处理哈希碰撞和极端情况是非常重要的。

### HashMap 的时间复杂度

1. **插入(put)操作**: 平均时间复杂度为 O(1)。
2. **查找(get)操作**: 平均时间复杂度为 O(1)。
3. **删除(remove)操作**: 平均时间复杂度为 O(1)。

这些操作的平均时间复杂度为 O(1),是因为 `HashMap` 使用哈希表来存储数据,通过计算键的哈希码来快速定位存储位置。

### 处理哈希碰撞

哈希碰撞是指不同的键具有相同的哈希值,并且它们被分配到哈希表的同一个桶中。Java 的 `HashMap` 通过以下方式处理哈希碰撞:

1. **链地址法(Separate Chaining)**:

   - 初期使用链表: 当两个键的哈希值相同时,它们会被存储在同一个链表中。
   - 链表转为红黑树: 如果单个桶中的元素数量过多(默认阈值为 8),链表会被转换为红黑树,以优化查找性能,红黑树的查找时间复杂度为 O(log n)。

2. **开放地址法(Open Addressing)**:
   - `HashMap` 主要使用链地址法,但在某些情况下,哈希表也可以使用开放地址法,其中包括线性探测,二次探测或双重散列等策略来解决碰撞。

### HashMap 的最极端时间复杂度

在最坏的情况下,`HashMap` 的时间复杂度可能会退化为 O(n)。这通常发生在以下几种情况下:

1. **所有键的哈希值都相同**: 如果所有插入的键都映射到哈希表的同一个桶中,所有元素将会存储在同一个链表或红黑树中。

   - 在链表的情况下,插入,查找和删除的时间复杂度将变为 O(n)。
   - 在红黑树的情况下,时间复杂度将变为 O(log n)。

2. **大量哈希碰撞**: 虽然不太常见,但如果发生大量哈希碰撞,导致许多元素集中在少数几个桶中,性能也会大幅下降。

### 小结

- **平均情况**: `HashMap` 的插入,查找和删除操作的时间复杂度为 O(1)。
- **最坏情况**: `HashMap` 的时间复杂度可能退化为 O(n),具体情况取决于哈希碰撞的处理方式和碰撞的数量。
- **处理哈希碰撞**: `HashMap` 主要使用链地址法,通过链表和红黑树来处理碰撞。

通过了解这些复杂度和处理方式,可以更好地使用 `HashMap` 以及应对潜在的性能问题。
